<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: 大纲</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">大纲 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li>协程模块：实现协程创建、协程切换等功能，提供给外部用户协程接口。<ol type="a">
<li>实现的是非对称协程，其中的一个主协程用于帮助协程切换</li>
<li>主协程不需要申请堆空间，直接使用的是线程栈</li>
</ol>
</li>
<li>协程HOOK模块：hook网络函数如read、write、accept、connect等。</li>
<li>Reactor模块:基于epoll系列函数实现Reactor框架。</li>
<li>定时器模块：实现基本的定时器，结合reactor模块使用。</li>
<li>Tcp模块：包含基本的TcpServer、TcpClient、TcpConnection、TcpBuffer、NetAddress等类的封装。</li>
<li>RPC模块：基于Tcp的进一步封装，预计使用Protobuf进行序列化实现RPC。</li>
<li>其他模块：如日志、线程池、互斥锁等模块。</li>
</ol>
<h1><a class="anchor" id="autotoc_md1"></a>
使用</h1>
<ul>
<li>调用<ul>
<li>阻塞协程式异步调用<ul>
<li>同步的代码，实现异步的性能（不需要回调函数和新建线程）</li>
<li>当请求远程方法的时候，线程不会阻塞在这里，而是去处理其他协程<ul>
<li>当前协程会切换到主协程</li>
<li>但是对于当前协程是阻塞的，只有被唤醒之后才能继续下面的操作</li>
</ul>
</li>
</ul>
</li>
<li>非阻塞协程式异步调用(使用于不依赖RPC调用结果的场景)<ul>
<li>类似<code>std::future</code></li>
<li>协程调用之后会立即返回，不会在这个调用中阻塞<ul>
<li>可以调用wait方法，这时候协程会阻塞，直到返回调用结果（遇到wait就阻塞）</li>
</ul>
</li>
<li>原理<ul>
<li>新生成一个协程处理这次调用</li>
<li>把这个处理用的协程放到调度池任务中，原来的协程继续完成任务</li>
</ul>
</li>
<li>注意事项<ul>
<li>所有人RPC相关对象必须是堆上的对象而不是栈上的<ul>
<li>调用对象是在线程A中声明的，由于是异步RPC，整个调用过程是在线程B中执行的，所以需要保证在线程B中这些对象还存在</li>
</ul>
</li>
<li>调用RPC之前需要调用saveCalle，增加智能指针的引用次数，防止调用返回之后引用次数将为0而被销毁<ul>
<li>防止线程切换导致对象销毁？（上面的双重保险）</li>
</ul>
</li>
</ul>
</li>
<li>具体实现<ul>
<li>继承类HttpServlet，重写handel方法<ul>
<li>HttpServlet中包含对HTTP报头的处理(Not found, set HTTP code etc)</li>
</ul>
</li>
<li>将serverlet注册到对应的目录下<ul>
<li>使用的宏定义，用do...while循环，来将几个语句变成一个语句</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>TinyPB 协议<ul>
<li>err_code: 框架级别的错误码</li>
<li>service_full_name: 调用的完整方法名</li>
</ul>
</li>
<li>HTTP模块<ul>
<li>每来一个 HTTP 请求就会找到对应的 HttpServlet 对象，执行其提前注册好的业务逻辑函数，用于处理 Http 请求，并回执 Http 响应。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Gooddbird/tinyrpc/main/imgs/nonblock_async_call.drawio.png" alt="非阻塞式异步RPC调用" class="inline"/></p>
<ul>
<li>m:n 线程:协程模型<ul>
<li>1:n 模型可能会增加请求的时延。例如当某个 IO 线程在处理请求时，耗费了太多的时间，导致此 IO 线程的其他请求得不到及时处理，只能阻塞等待。</li>
<li>m:n 即 m 个线程共同调度 n 个协程。由于 m 个线程共用一个协程池，因此协程池里的就绪任务总会尽快的被 Resume。<ul>
<li>每一个客户端连接对象 TcpConnection, 对应一个协程。对客户端连接的 读数据、业务处理、写数据这三步，其实都在这个协程中完成的</li>
<li>对于 m:n 协程模型 来说，一个 TcpConnection对象所持有的协程，可能会来回被多个不同的IO线程调度。</li>
</ul>
</li>
<li>m:n 模型也引入了更强的线程竞争条件，所以对协程池加互斥锁是必须的。</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
支持的协议报文</h1>
<ol type="1">
<li>纯HTTP1.1</li>
<li>TinyPB 协议: 一种基于 Protobuf 的自定义协议，属于二进制协议。 </li>
</ol>
<h1><a class="anchor" id="autotoc_md3"></a>
knowledge</h1>
<ul>
<li>Servlet &amp; CGI <blockquote class="doxtable">
<p>- CGI ，是通过 fork and exec 对应路径下的 CGI 程序并且启动后进行处理。不过 CGI 最大的诟病是每次请求要 fork 一次，尽管 fcgi 的出现一定程度解决了这个问题，但还是有一定的性能丢失。</p>
</blockquote>
</li>
<li>Servlet 就是一段子程序，它接收 HTTP 请求，返回 HTTP 响应。<ul>
<li>it will listen for incoming HTTP requests and route them to the appropriate serverlet based on the requested URL.</li>
<li>它接收 HTTP 请求，返回 HTTP 响应。Servlet 需要被注册到一个路径下，如 /user，当浏览器访问这个路径时，就会找到对应的 Servlet 程序。 </li>
</ul>
</li>
</ul>
<p>- 协程</p><ul>
<li>本项目中实现的是有栈非对称协程<ul>
<li>协程拥有自己的调用栈</li>
</ul>
</li>
<li>基于非对称协程的设计，一般都需要一个主协程。通常主协程就直接使用线程所在的栈，而新的协程需要额外申请从堆中申请内存空间来作为其执行时的栈空间。</li>
<li>任何切换到新协程的操作都必须由主协程来执行。<ul>
<li>必须在当前协程是主协程的情况下才行唤醒其他目标协程。（Resume）</li>
<li>挂起协程的目的就是为了切换到主协程。（Yield）</li>
</ul>
</li>
</ul>
<p>core dump</p><ul>
<li>A core dump contains a snapshot of the program's memory, including any source code that was being executed at the time of the crash, as well as any data that may have been in memory.</li>
<li>Core dump是当程序出现异常时，系统将程序正在使用的内存内容储存到一个核心文件中，以便于诊断，调试故障的一个技术。</li>
</ul>
<p>Hook函数</p><ul>
<li>在hook之后，我们自己提供了一份 read函数，如何保证程序加载的是我们Hook后的read函数，而不是系统自带的read函数呢。 <blockquote class="doxtable">
<p>在linux下，如果多个动态库有同名的全局符号的情况下，会加载第一个动态库中的符号，而忽略后面的动态库中的同名符号。因此，我们需要修改动态链接顺序，只要保证自己的库在glibc库之前被加载就可以了，最好把自己的库放在最前面。 </p>
</blockquote>
</li>
</ul>
<p>利用时间轮处理无效TCP连接</p><ul>
<li>服务器维持一个 TCP 连接大约占用哪些资源: 文件描述符、内核收发缓冲区、CPU资源、内存资源</li>
<li>分解问题<ul>
<li>服务器如何识别一个连接是无效连接</li>
<li>服务器如何断开这个连接</li>
</ul>
</li>
</ul>
<p>Reactor</p><ul>
<li>TinyRPC 是多线程模型，根据<code>one loop per thread</code>的理念。主线程就是 MainReactor，而每个 IO 线程就是一个 SubReactor。<ul>
<li><code>one loop per thread</code>理念指的是以线程为单位进行编程，即每个线程负责一个循环，而不是将某些任务分配给不同的线程去执行。</li>
</ul>
</li>
<li>也就是说，对于 read 协程来看，它的执行流都是同步的，但是性能却是异步的！ 即同步的写法达到异步的性能，这也是协程的最大好处。有了这个，写代码就容易多了。就像写最简单的阻塞式编程一样，一路直接 accept、read、write 就行了，根本不要考虑注册什么回调。协程 hook 配合 Reactor 已经完全帮我们做好了。<ul>
<li>在原先实现异步的过程需要设置回调函数</li>
</ul>
</li>
<li><b>定时器</b><ul>
<li>定时器其实也很简单，说白了就是个任务队列，队列中每个元素由两部分组成：执行时间点 + 执行函数。</li>
<li>如何在给定时间触发对应事件？<ul>
<li>将epoll_wait中的超时时间设置为任务队列中最早的执行时间</li>
<li>利用Linux的新增特征，timefd，当到时间之后，这个fd就会发生可读事件，之后epoll_wait返回，去执行其上绑定的定时任务</li>
</ul>
</li>
<li>唤醒<ul>
<li>使用Linux中提供的eventfd， 直接创建一个这种 fd 并注册到 epoll_wait 上即可。当我们需要唤醒 epoll_wait 的时候，往这个 fd 里面写入数据即可。</li>
<li>&gt; Eventfd是Linux内核中的一种用于通信和同步的机制，它可以让内核和用户空间之间进行传递数据。Eventfd通过一个文件描述符，允许应用程序使用文件I/O来监视和触发事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>TCP server</p><ul>
<li>TcpServer有两个协程，一个是主协程，执行reactor的循环，另一个accept的协程，会不断循环的去 accept，每当 accept 返回时就取出这个连接，交给某一个 IO 线程（也即 SubReactor）<ul>
<li>TinyRPC 是主从 Reactor 架构。TcpServer 本身是 MainReactor, 每个 IO 线程是一个SubReactor.</li>
</ul>
</li>
</ul>
<p>网络服务器</p><ul>
<li>读数据</li>
<li>事件处理</li>
<li>写数据</li>
</ul>
<p>事件处理</p><ul>
<li>将请求数据包**解码**生成事件</li>
<li>根据协议类型**分发**事件</li>
<li>事件业务逻辑处理</li>
<li>**编码**生成响应数据包</li>
</ul>
<h1><a class="anchor" id="autotoc_md4"></a>
questions</h1>
<ul>
<li>这里为什么要做内存对齐？因为这段空间会被当成新协程的执行栈空间来说，在栈空间进行 Push或者Pop操作时一般都是以机器字长为单位的，在64位下就是8个字节。也就是说每次Push或者Pop的数据都是8个字节，想一下，如果栈顶指针执行的地址不是8字节的整数倍，Push和Pop是不是很难执行？</li>
<li>为什么要用宏定义定义函数，而不是直接定义一个常规函数？<ul>
<li>&gt; 宏定义的函数用来执行某种特定任务，可提高代码的运行效率，允许在编译时完成大量的处理，而常规函数只能在运行时执行代码，不允许编译时做处理。另外，宏定义函数可以有效地减少重复代码量，提高代码的可读性，使程序更容易理解和维护。 </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
项目特点</h1>
<ul>
<li>关于智能指针<ul>
<li><p class="startli">时间轮 ```cpp // 注意这里并没有去寻找这个 AbstractSlot 的shared_ptr 指针是否已经存在时间轮里面了，而是直接新增了一个 shared_ptr。这是有意为之的，没有必要再去时间轮遍历一下找到之前添加的 shared_ptr，然后再删除，再添加到队尾。既然用了智能指针了，自然是通过 shard_ptr 的自动计数功能，反正当最后一个 shared_ptr 被删除后，这个 slot 对象自然就析构了。这个特性解决了之前需要 O(N) 来遍历的问题。 void TcpTimeWheel::fresh(TcpConnectionSlot::ptr slot) { DebugLog &lt;&lt; "fresh connection"; m_wheel.back().emplace_back(slot); }</p>
<p class="startli">// 注意这里必须用 weak_ptr 而不能用 shread_ptr，否则不管时间轮那里有没有这个 slot 对象的 shared_ptr 指针，这个 slot 永远不会销毁，因为 TcpConnection 始终持有一个 shared_ptr，导致引用计数一直大于0。这个就是典型的智能指针循环引用的问题了。 void TcpConnection::registerToTimeWheel() { auto cb = [] (TcpConnection::ptr conn) { conn-&gt;shutdownConnection(); }; TcpTimeWheel::TcpConnectionSlot::ptr tmp = std::make_shared&lt;AbstractSlot&lt;TcpConnection&gt;&gt;(shared_from_this(), cb); m_weak_slot = tmp; // std::weak_ptr&lt;tinyrpc::AbstractSlot&lt;tinyrpc::TcpConnection&gt;&gt; tinyrpc::TcpConnection::m_weak_slot m_tcp_svr-&gt;freshTcpConnection(tmp); } ```</p>
</li>
</ul>
</li>
<li>acceptor中的listenfd是否需要设置成非阻塞？<ul>
<li>&gt; 不一定，在Reactor模型中有一个原则<code>Robot:宏定义的函数用来执行某种特定任务，可提高代码的运行效率，允许在编译时完成大量的处理，而常规函数只能在运行时执行代码，不允许编译时做处理。另外，宏定义函数可以有效地减少重复代码量，提高代码的可读性，使程序更容易理解和维护。</code>但是在使用accept的时候，只要有新连接，那就不会阻塞（也就是一般知道listenfd可读之后才调用accept），所以也不一定要设置成非阻塞</li>
<li>为什么要用 SO_REUSEADDR<ul>
<li>当服务端意外重启之后，服务器会尝试重新连接原先的地址、端口，如果不可重用的话，这样的连接尝试会失败，因为the operating system would still think the port was in use</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md6"></a>
bug</h1>
<ul>
<li>undefi undefined reference to `google::protobuf <div class="fragment"><div class="line"># 添加了 -ldl -lprotobuf -pthread 中的-lprotobuf，只在前三个中添加了</div>
<div class="line">$(PATH_BIN)/test_tinypb_server: $(LIB_OUT)</div>
<div class="line">    $(CXX) $(CXXFLAGS) $(PATH_TESTCASES)/test_tinypb_server.cc $(PATH_TESTCASES)/test_tinypb_server.pb.cc -o $@ $(LIB_OUT) $(LIBS) -ldl -lprotobuf -pthread $(PLUGIN_LIB)</div>
<div class="line"> </div>
<div class="line">$(PATH_BIN)/test_tinypb_server_client: $(LIB_OUT)</div>
<div class="line">    $(CXX) $(CXXFLAGS) $(PATH_TESTCASES)/test_tinypb_server_client.cc $(PATH_TESTCASES)/test_tinypb_server.pb.cc -o $@ $(LIB_OUT) $(LIBS) -ldl -lprotobuf -pthread $(PLUGIN_LIB)</div>
<div class="line"> </div>
<div class="line">$(PATH_BIN)/test_http_server: $(LIB_OUT)</div>
<div class="line">    $(CXX) $(CXXFLAGS) $(PATH_TESTCASES)/test_http_server.cc $(PATH_TESTCASES)/test_tinypb_server.pb.cc -o $@ $(LIB_OUT) $(LIBS) -ldl -lprotobuf -pthread $(PLUGIN_LIB)</div>
</div><!-- fragment --> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
