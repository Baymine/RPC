<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This directory contains <em>CMake</em> files that can be used to build protobuf with <em>MSVC</em> on <em>Windows</em>. You can build the project from <em>Command Prompt</em> and using an <em>Visual Studio</em> IDE.</p>
<p>You need to have <a href="http://www.cmake.org">CMake</a>, <a href="https://www.visualstudio.com">Visual Studio</a> and optionally <a href="http://git-scm.com">Git</a> installed on your computer before proceeding.</p>
<p>Most of the instructions will be given to the <em>Сommand Prompt</em>, but the same actions can be performed using appropriate GUI tools.</p>
<h1><a class="anchor" id="autotoc_md93"></a>
Environment Setup</h1>
<p>Open the appropriate <em>Command Prompt</em> from the <em>Start</em> menu.</p>
<p>For example <em>x86 Native Tools Command Prompt for VS 2019</em>: </p><pre class="fragment">C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional&gt;
</pre><p> Change to your working directory: </p><pre class="fragment">C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional&gt;cd C:\Path\to
C:\Path\to&gt;
</pre><p> Where *C:\Path\to* is path to your real working directory.</p>
<p>Create a folder where protobuf headers/libraries/binaries will be installed after built: </p><pre class="fragment">C:\Path\to&gt;mkdir install
</pre><p> If <em>cmake</em> command is not available from <em>Command Prompt</em>, add it to system <em>PATH</em> variable: </p><pre class="fragment">C:\Path\to&gt;set PATH=%PATH%;C:\Program Files (x86)\CMake\bin
</pre><p> If <em>git</em> command is not available from <em>Command Prompt</em>, add it to system <em>PATH</em> variable: </p><pre class="fragment">C:\Path\to&gt;set PATH=%PATH%;C:\Program Files\Git\cmd
</pre><p> Optionally, you will want to download <a href="https://ninja-build.org/">ninja</a> and add it to your <em>PATH</em> variable. </p><pre class="fragment">C:\Path\to&gt;set PATH=%PATH%;C:\tools\ninja
</pre><p> Good. Now you are ready to continue.</p>
<h1><a class="anchor" id="autotoc_md94"></a>
Getting Sources</h1>
<p>You can get the latest stable source packages from the release page: </p><pre class="fragment">https://github.com/protocolbuffers/protobuf/releases/latest
</pre><p> For example: if you only need C++, download <code>protobuf-cpp-[VERSION].tar.gz</code>; if you need C++ and Java, download <code>protobuf-java-[VERSION].tar.gz</code> (every package contains C++ source already); if you need C++ and multiple other languages, download <code>protobuf-all-[VERSION].tar.gz</code>.</p>
<p>Or you can use git to clone from protobuf git repository. </p><pre class="fragment"> C:\Path\to&gt; mkdir src &amp; cd src
 C:\Path\to\src&gt; git clone -b [release_tag] https://github.com/protocolbuffers/protobuf.git
</pre><p> Where <em>[release_tag]</em> is a git tag like <em>v3.0.0-beta-1</em> or a branch name like <em>main</em> if you want to get the latest code.</p>
<p>Go to the project folder: </p><pre class="fragment"> C:\Path\to\src&gt; cd protobuf
 C:\Path\to\src\protobuf&gt;
</pre><p> Remember to update any submodules if you are using git clone (you can skip this step if you are using a release .tar.gz or .zip package):</p>
<div class="fragment"><div class="line">C:\Path\to\src\protobuf&gt; git submodule update --init --recursive</div>
</div><!-- fragment --><p>Good. Now you are ready for <em>CMake</em> configuration.</p>
<h1><a class="anchor" id="autotoc_md95"></a>
CMake Configuration</h1>
<p><em>CMake</em> supports a lot of different <a href="http://www.cmake.org/cmake/help/latest/manual/cmake-generators.7.html">generators</a> for various native build systems.</p>
<p>Of most interest to Windows programmers are the following:</p>
<ul>
<li><a href="http://www.cmake.org/cmake/help/latest/manual/cmake-generators.7.html#makefile-generators">Makefile</a>. This generates NMake Makefiles for Visual Studio. These work, but they are rather slow.</li>
<li><a href="http://www.cmake.org/cmake/help/latest/manual/cmake-generators.7.html#visual-studio-generators">Visual Studio</a> This generates a Visual Studio solution for the project.</li>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-generators.7.html#ninja-generator">Ninja</a> This uses the external tool <a href="https://ninja-build.org/">Ninja</a> to build. It is the fastest solution available.</li>
</ul>
<p>Note that as of Visual Studio 2015, Visual Studio includes <a href="https://docs.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio">support for opening directly CMake-based projects</a>.</p>
<p>It is considered good practice not to build CMake projects in the source tree but in a separate folder.</p>
<p>Create a temporary <em>build</em> folder and change your working directory to it: </p><pre class="fragment"> mkdir C:\Path\to\build\protobuf
 cd C:\Path\to\build\protobuf
 C:\Path\to\build\protobuf&gt;
</pre><p> The <em>Makefile</em> and <em>Ninja</em> generators can build the project in only one configuration, so you need to build a separate folder for each configuration.</p>
<p>To start using a <em>Release</em> configuration via the <em>NMmake</em> generator: </p><pre class="fragment"> C:\Path\to\build\protobuf&gt;mkdir release &amp; cd release
 C:\Path\to\build\protobuf\release&gt;cmake -G "NMake Makefiles" ^
 -DCMAKE_BUILD_TYPE=Release ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install ^
 C:\Path\to\src\protobuf
</pre><p> It will generate a <em>NMake</em> <em>Makefile</em> in the current directory.</p>
<p>To use <em>Debug</em> configuration using <em>Ninja</em>: </p><pre class="fragment"> C:\Path\to\build\protobuf&gt;mkdir debug &amp; cd debug
 C:\Path\to\build\protobuf\debug&gt;cmake -G "Ninja" ^
 -DCMAKE_BUILD_TYPE=Debug ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install ^
 C:\Path\to\src\protobuf
</pre><p> It will generate <em>Ninja</em> build scripts in current directory.</p>
<p>The <em>Visual Studio</em> generator is multi-configuration: it will generate a single *.sln* file that can be used for both <em>Debug</em> and <em>Release</em>: </p><pre class="fragment"> C:\Path\to\build\protobuf&gt;mkdir solution &amp; cd solution
 C:\Path\to\build\protobuf\solution&gt;cmake -G "Visual Studio 16 2019" ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install ^
 C:\Path\to\src\protobuf
</pre><p> It will generate <em>Visual Studio</em> solution file <em>protobuf.sln</em> in current directory.</p>
<h2><a class="anchor" id="autotoc_md96"></a>
Unit Tests</h2>
<p>Unit tests are being built along with the rest of protobuf. The unit tests require Google <a class="el" href="classMock.html">Mock</a> (now a part of Google <a class="el" href="classTest.html">Test</a>).</p>
<p>A copy of <a href="https://github.com/google/googletest">Google Test</a> is included as a Git submodule in the <code>third-party/googletest</code> folder. (You do need to initialize the Git submodules as explained above.)</p>
<p>Alternately, you may want to use protobuf in a larger set-up, you may want to use that standard CMake approach where you build and install a shared copy of Google <a class="el" href="classTest.html">Test</a>.</p>
<p>After you've built and installed your Google <a class="el" href="classTest.html">Test</a> copy, you need add the following definition to your <em>cmake</em> command line during the configuration step: <code>-Dprotobuf_USE_EXTERNAL_GTEST=ON</code>. This will cause the standard CMake <code>find_package(GTest REQUIRED)</code> to be used.</p>
<p><a href="https://cmake.org/cmake/help/latest/command/find_package.html">find_package</a> will search in a default location, which on Windows is *C:\Program Files*. This is most likely not what you want. You will want instead to search for Google <a class="el" href="classTest.html">Test</a> in your project's root directory (i.e. the same directory you've passed to <code>CMAKE_INSTALL_PREFIX</code> when building Google <a class="el" href="classTest.html">Test</a>). For this, you need to set the <code>CMAKE_PREFIX_PATH</code> CMake variable. (There are other ways in CMake, see the <a href="https://cmake.org/cmake/help/latest/command/find_package.html">manual</a> for details.)</p>
<p>For example: </p><pre class="fragment"> C:\Path\to\build\protobuf&gt;mkdir solution &amp; cd solution
 C:\Path\to\build\protobuf\solution&gt;cmake -G "Visual Studio 16 2019" ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install ^
 -DCMAKE_PREFIX_PATH=C:\Path\to\my_big_project ^
 -Dprotobuf_USE_EXTERNAL_GTEST=ON ^
 C:\Path\to\src\protobuf
</pre><p> In most cases, <code>CMAKE_PREFIX_PATH</code> and <code>CMAKE_INSTALL_PREFIX</code> will point to the same directory.</p>
<p>To disable testing completely, you need to add the following argument to you <em>cmake</em> command line: <code>-Dprotobuf_BUILD_TESTS=OFF</code>.</p>
<p>For example: </p><pre class="fragment"> C:\Path\to\build\protobuf\solution&gt;cmake -G "Visual Studio 16 2019" ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install ^
 -Dprotobuf_BUILD_TESTS=OFF ^
 C:\Path\to\src\protobuf
</pre> <h1><a class="anchor" id="autotoc_md97"></a>
Compiling</h1>
<p>The standard way to compile a <em>CMake</em> project is <code>cmake --build &lt;directory&gt;</code>.</p>
<p>Note that if your generator supports multiple configurations, you will probably want to specify which one to build: </p><pre class="fragment"> cmake --build C:\Path\to\build\protobuf\solution --config Release
</pre><p> You can also run directly the build tool you've configured: </p><pre class="fragment"> C:\Path\to\build\protobuf\release&gt;nmake
</pre><p> or </p><pre class="fragment"> C:\Path\to\build\protobuf\debug&gt;ninja
</pre><p> And wait for the compilation to finish.</p>
<p>If you prefer to use the IDE:</p>
<ul>
<li>Open the generated protobuf.sln file in Microsoft Visual Studio.</li>
<li>Choose "Debug" or "Release" configuration as desired.</li>
<li>From the Build menu, choose "Build Solution".</li>
</ul>
<p>And wait for the compilation to finish.</p>
<h1><a class="anchor" id="autotoc_md98"></a>
Testing</h1>
<p>To run unit-tests, first you must compile protobuf as described above. Then run: </p><pre class="fragment"> C:\Path\to\protobuf\cmake\build\release&gt;ctest --progress --output-on-failure
</pre><p> You can also build the <code>check</code> target (not idiomatic CMake usage, though): </p><pre class="fragment"> C:\Path\to\protobuf\cmake\build\release&gt;cmake --build . --target check
</pre><p> or </p><pre class="fragment">C:\Path\to\build\protobuf\release&gt;ninja check
</pre><p> You can also build project <em>check</em> from Visual Studio solution. Yes, it may sound strange, but it works.</p>
<p>You should see output similar to: </p><pre class="fragment"> Running main() from gmock_main.cc
 [==========] Running 1546 tests from 165 test cases.

 ...

 [==========] 1546 tests from 165 test cases ran. (2529 ms total)
 [  PASSED  ] 1546 tests.
</pre><p> To run specific tests, you need to pass some command line arguments to the test program itself: </p><pre class="fragment"> C:\Path\to\build\protobuf\release&gt;tests.exe --gtest_filter=AnyTest*
 Running main() from gmock_main.cc
 Note: Google Test filter = AnyTest*
 [==========] Running 3 tests from 1 test case.
 [----------] Global test environment set-up.
 [----------] 3 tests from AnyTest
 [ RUN      ] AnyTest.TestPackAndUnpack
 [       OK ] AnyTest.TestPackAndUnpack (0 ms)
 [ RUN      ] AnyTest.TestPackAndUnpackAny
 [       OK ] AnyTest.TestPackAndUnpackAny (0 ms)
 [ RUN      ] AnyTest.TestIs
 [       OK ] AnyTest.TestIs (0 ms)
 [----------] 3 tests from AnyTest (1 ms total)

 [----------] Global test environment tear-down
 [==========] 3 tests from 1 test case ran. (2 ms total)
 [  PASSED  ] 3 tests.
</pre><p> Note that the tests must be run from the source folder.</p>
<p>If all tests are passed, safely continue.</p>
<h1><a class="anchor" id="autotoc_md99"></a>
Installing</h1>
<p>To install protobuf to the <em>install</em> folder you've specified in the configuration step, you need to build the <code>install</code> target: </p><pre class="fragment"> cmake --build C:\Path\to\build\protobuf\solution --config Release --target install
</pre><p> Or if you prefer: </p><pre class="fragment"> C:\Path\to\build\protobuf\release&gt;nmake install
</pre><p> or </p><pre class="fragment"> C:\Path\to\build\protobuf\debug&gt;ninja install
</pre><p> You can also build project <em>INSTALL</em> from Visual Studio solution. It sounds not so strange and it works.</p>
<p>This will create the following folders under the <em>install</em> location:</p><ul>
<li>bin - that contains protobuf <em>protoc.exe</em> compiler;</li>
<li>include - that contains C++ headers and protobuf *.proto files;</li>
<li>lib - that contains linking libraries and <em>CMake</em> configuration files for <em>protobuf</em> package.</li>
</ul>
<p>Now you can if needed:</p><ul>
<li>Copy the contents of the include directory to wherever you want to put headers.</li>
<li>Copy protoc.exe wherever you put build tools (probably somewhere in your PATH).</li>
<li>Copy linking libraries libprotobuf[d].lib, libprotobuf-lite[d].lib, and libprotoc[d].lib wherever you put libraries.</li>
</ul>
<p>To avoid conflicts between the MSVC debug and release runtime libraries, when compiling a debug build of your application, you may need to link against a debug build of libprotobufd.lib with "d" postfix. Similarly, release builds should link against release libprotobuf.lib library.</p>
<h1><a class="anchor" id="autotoc_md100"></a>
DLLs vs. static linking</h1>
<p>Static linking is now the default for the Protocol Buffer libraries. Due to issues with Win32's use of a separate heap for each DLL, as well as binary compatibility issues between different versions of MSVC's STL library, it is recommended that you use static linkage only. However, it is possible to build libprotobuf and libprotoc as DLLs if you really want. To do this, do the following:</p>
<ul>
<li>Add an additional flag <code>-Dprotobuf_BUILD_SHARED_LIBS=ON</code> when invoking cmake</li>
<li>Follow the same steps as described in the above section.</li>
<li>When compiling your project, make sure to <code>#define PROTOBUF_USE_DLLS</code>.</li>
</ul>
<p>When distributing your software to end users, we strongly recommend that you do NOT install libprotobuf.dll or libprotoc.dll to any shared location. Instead, keep these libraries next to your binaries, in your application's own install directory. C++ makes it very difficult to maintain binary compatibility between releases, so it is likely that future versions of these libraries will <em>not</em> be usable as drop-in replacements.</p>
<p>If your project is itself a DLL intended for use by third-party software, we recommend that you do NOT expose protocol buffer objects in your library's public interface, and that you statically link protocol buffers into your library.</p>
<h1><a class="anchor" id="autotoc_md101"></a>
ZLib support</h1>
<p>If you want to include GzipInputStream and GzipOutputStream (<a class="el" href="gzip__stream_8h_source.html">google/protobuf/io/gzip_stream.h</a>) in libprotobuf, you will need to do a few additional steps.</p>
<p>Obtain a copy of the zlib library. The pre-compiled DLL at zlib.net works. You need prepare it:</p>
<ul>
<li>Make sure zlib's two headers are in your <code>C:\Path\to\install\include</code> path</li>
<li>Make sure zlib's linking libraries (*.lib file) is in your <code>C:\Path\to\install\lib</code> library path.</li>
</ul>
<p>You can also compile it from source by yourself.</p>
<p>Getting sources: </p><pre class="fragment"> C:\Path\to\src&gt;git clone -b v1.2.8 https://github.com/madler/zlib.git
 C:\Path\to\src&gt;cd zlib
</pre><p> Compiling and Installing: </p><pre class="fragment"> C:\Path\to\src\zlib&gt;mkdir C:\Path\to\build\zlib &amp; cd C:\Path\to\build\zlib
 C:\Path\to\build\zlib&gt;mkdir release &amp; cd release
 C:\Path\to\build\zlib\release&gt;cmake -G "Ninja" -DCMAKE_BUILD_TYPE=Release ^
 -DCMAKE_INSTALL_PREFIX=C:\Path\to\install C:\Path\to\src\zlib
 C:\Path\to\src\zlib\build\release&gt;cmake --build . --target install
</pre><p> You can make <em>debug</em> version or use <em>Visual Studio</em> generator also as before for the protobuf project.</p>
<p>Now add <em>bin</em> folder from <em>install</em> to system <em>PATH</em>: </p><pre class="fragment"> C:\Path\to&gt;set PATH=%PATH%;C:\Path\to\install\bin
</pre><p> You need reconfigure protobuf with flag <code>-Dprotobuf_WITH_ZLIB=ON</code> when invoking cmake.</p>
<p>Note that if you have compiled ZLIB yourself, as stated above, further disable the option <code>-Dprotobuf_MSVC_STATIC_RUNTIME=OFF</code>.</p>
<p>If it reports NOTFOUND for zlib_include or zlib_lib, you might haven't put the headers or the .lib file in the right directory.</p>
<p>If you already have ZLIB library and headers at some other location on your system then alternatively you can define following configuration flags to locate them: </p><pre class="fragment"> -DZLIB_INCLUDE_DIR=&lt;path to dir containing zlib headers&gt;
 -DZLIB_LIB=&lt;path to dir containing zlib&gt;
</pre><p> Build and testing protobuf as usual.</p>
<h1><a class="anchor" id="autotoc_md102"></a>
Notes on Compiler Warnings</h1>
<p>The following warnings have been disabled while building the protobuf libraries and compiler. You may have to disable some of them in your own project as well, or live with them.</p>
<ul>
<li>C4244 - Conversion from 'type1' to 'type2', possible loss of data.</li>
<li>C4251 - 'identifier' : class 'type' needs to have dll-interface to be used by clients of class 'type2'</li>
<li>C4267 - Conversion from 'size_t' to 'type', possible loss of data.</li>
<li>C4305 - 'identifier' : truncation from 'type1' to 'type2'</li>
<li>C4355 - 'this' : used in base member initializer list</li>
<li>C4800 - 'type' : forcing value to bool 'true' or 'false' (performance warning)</li>
<li>C4996 - 'function': was declared deprecated</li>
</ul>
<p>C4251 is of particular note, if you are compiling the Protocol Buffer library as a DLL (see previous section). The protocol buffer library uses templates in its public interfaces. MSVC does not provide any reasonable way to export template classes from a DLL. However, in practice, it appears that exporting templates is not necessary anyway. Since the complete definition of any template is available in the header files, anyone importing the DLL will just end up compiling instances of the templates into their own binary. The Protocol Buffer implementation does not rely on static template members being unique, so there should be no problem with this, but MSVC prints warning nevertheless. So, we disable it. Unfortunately, this warning will also be produced when compiling code which merely uses protocol buffers, meaning you may have to disable it in your code too. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
