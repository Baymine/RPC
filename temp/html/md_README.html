<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- 制作者 Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'搜索','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','搜索');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><img src="https://img.shields.io/github/v/release/Gooddbird/tinyrpc?color=2&amp;label=tinyrpc&amp;logoColor=2&amp;style=plastic" alt="" class="inline"/> <img src="https://img.shields.io/github/repo-size/Gooddbird/tinyrpc?style=plastic" alt="GitHub repo size" class="inline"/> <img src="https://img.shields.io/github/issues/Gooddbird/tinyrpc?style=plastic" alt="GitHub issues" class="inline"/> <img src="https://img.shields.io/github/issues-pr/Gooddbird/tinyrpc?style=plastic" alt="GitHub pull requests" class="inline"/> <img src="https://img.shields.io/github/forks/Gooddbird/tinyrpc?style=plastic" alt="GitHub forks" class="inline"/> <img src="https://img.shields.io/github/stars/Gooddbird/tinyrpc?style=plastic" alt="GitHub Repo stars" class="inline"/> <img src="https://img.shields.io/github/contributors/Gooddbird/tinyrpc?style=plastic" alt="GitHub contributors" class="inline"/> <img src="https://img.shields.io/github/last-commit/Gooddbird/tinyrpc" alt="GitHub last commit" class="inline"/></p>
<p>作者：**ikerli** <b>2022-05-13</b> <b>使用 TinyRPC, 轻松地构建高性能分布式 RPC 服务！</b></p>
<ul>
<li><a href="#1-概述">1. 概述</a><ul>
<li><a href="#11-tinyrpc-特点">1.1. TinyRPC 特点</a></li>
<li><a href="#12-tinyrpc-支持的协议报文">1.2. TinyRPC 支持的协议报文</a></li>
<li><a href="#13-tinyrpc-的-rpc-调用">1.3. TinyRPC 的 RPC 调用</a><ul>
<li><a href="#131-阻塞协程式异步调用">1.3.1. 阻塞协程式异步调用</a></li>
<li><a href="#132-非阻塞协程式异步调用">1.3.2. 非阻塞协程式异步调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-性能测试">2. 性能测试</a><ul>
<li><a href="#21-http-echo-测试-qps">2.1. HTTP echo 测试 QPS</a></li>
</ul>
</li>
<li><a href="#3-安装-tinyrpc">3. 安装 TinyRPC</a><ul>
<li><a href="#31-安装必要的依赖库">3.1. 安装必要的依赖库</a><ul>
<li><a href="#311-protobuf">3.1.1. protobuf</a></li>
<li><a href="#312-tinyxml">3.1.2. tinyxml</a></li>
</ul>
</li>
<li><a href="#32-安装和卸载">3.2. 安装和卸载</a><ul>
<li><a href="#321-安装-tinyrpc">3.2.1. 安装 TinyRPC</a></li>
<li><a href="#322-卸载-tinyrpc">3.2.2. 卸载 TinyRPC</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-快速上手">4. 快速上手</a><ul>
<li><a href="#41-搭建基于-tinypb-协议的-rpc-服务">4.1. 搭建基于 TinyPB 协议的 RPC 服务</a><ul>
<li><a href="#411-实现-protobuf-文件接口">4.1.1. 实现 Protobuf 文件接口</a></li>
<li><a href="#412-准备配置文件">4.1.2. 准备配置文件</a></li>
<li><a href="#413-实现业务接口">4.1.3. 实现业务接口</a></li>
<li><a href="#414-启动-rpc-服务">4.1.4. 启动 RPC 服务</a></li>
</ul>
</li>
<li><a href="#42-搭建基于-http-协议的-rpc-服务">4.2. 搭建基于 HTTP 协议的 RPC 服务</a><ul>
<li><a href="#421-准备配置文件">4.2.1. 准备配置文件</a></li>
<li><a href="#422-实现-servlet-接口">4.2.2. 实现 Servlet 接口</a></li>
<li><a href="#423-启动-rpc-服务">4.2.3. 启动 RPC 服务</a></li>
</ul>
</li>
<li><a href="#43-rpc-服务调用">4.3. RPC 服务调用</a><ul>
<li><a href="#431-阻塞协程式异步调用">4.3.1. 阻塞协程式异步调用</a></li>
<li><a href="#432-非阻塞协程式异步调用">4.3.2. 非阻塞协程式异步调用</a></li>
</ul>
</li>
<li><a href="#44-tinyrpc-脚手架tinyrpc_generator">4.4. TinyRPC 脚手架(tinyrpc_generator)</a><ul>
<li><a href="#441-准备-protobuf-文件">4.4.1 准备 protobuf 文件</a></li>
<li><a href="#442-生成-tinyrpc-框架">4.4.2 生成 TinyRPC 框架</a></li>
<li><a href="#443-业务逻辑开发">4.4.3 业务逻辑开发</a></li>
<li><a href="#444-protobuf-接口升级怎么办">4.4.4 Protobuf 接口升级怎么办？</a></li>
<li><a href="#445-tinyrpc_generator-选项详解">4.4.5 tinyrpc_generator 选项详解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-概要设计">5. 概要设计</a><ul>
<li><a href="#51-异步日志模块">5.1. 异步日志模块</a></li>
<li><a href="#52-协程模块">5.2. 协程模块</a><ul>
<li><a href="#521-协程封装">5.2.1. 协程封装</a></li>
<li><a href="#522-mn-线程协程模型">5.2.2. m:n 线程:协程模型</a></li>
</ul>
</li>
<li><a href="#53-reactor-模块">5.3. Reactor 模块</a></li>
<li><a href="#54-tcp-模块">5.4. Tcp 模块</a><ul>
<li><a href="#541-tcpserver">5.4.1. TcpServer</a></li>
<li><a href="#542-tcpconnection">5.4.2. TcpConnection</a></li>
</ul>
</li>
<li><a href="#55-tinypb-协议">5.5. TinyPB 协议</a><ul>
<li><a href="#551-tinypb-协议报文格式分解">5.5.1. TinyPB 协议报文格式分解</a></li>
</ul>
</li>
<li><a href="#56-http-模块">5.6. Http 模块</a></li>
<li><a href="#57-rpc-调用封装">5.7. RPC 调用封装</a></li>
</ul>
</li>
<li><a href="#6-错误码">6. 错误码</a><ul>
<li><a href="#61-错误码判断规范">6.1. 错误码判断规范</a></li>
<li><a href="#62-错误码释义文档">6.2. 错误码释义文档</a></li>
</ul>
</li>
<li><a href="#7-问题反馈">7. 问题反馈</a></li>
<li><a href="#8-参考资料">8. 参考资料</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md7"></a>
1. 概述</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
1.1. TinyRPC 特点</h2>
<p><b>TinyRPC</b> 是一款基于 <b>C++11</b> 标准开发的小型**异步 RPC** 框架。TinyRPC 的核心代码应该也就几千行样子，尽量保持了简洁且较高的易读性。</p>
<p>麻雀虽小五脏俱全，从命名上就能看出来，TinyRPC 框架主要用义是为了让读者能**快速地**、**轻量化**地搭建出具有较高性能的异步RPC 服务。至少用 TinyRPC 搭建的 RPC 服务能应付目前大多数场景了。</p>
<p><b>TinyRPC</b> 没有实现跨平台，只支持 Linux 系统，并且必须是 64 位的系统，因为协程切换只实现了 <b>64</b> 位系统的代码，而没有兼容 <b>32</b> 位系统。这是有意的，因为作者只会 Linux 下开发，没能力做到跨平台。</p>
<p><b>TinyRPC</b> 的核心思想有两个：</p><ol type="1">
<li>让搭建高性能 RPC 服务变得简单</li>
<li>让异步调用 RPC 变得简单</li>
</ol>
<p>必须说明的是， <b>TinyRPC</b> 代码没有达到工业强度，最好不要直接用到生产环境，也可能存在一些未知 BUG，甚至 coredump。读者请自行辨别，谨慎使用！</p>
<h2><a class="anchor" id="autotoc_md9"></a>
1.2. TinyRPC 支持的协议报文</h2>
<p><b>TinyRPC</b> 框架目前支持两类协议：</p><ol type="1">
<li>纯 <b>HTTP</b> 协议: TinyRPC 实现了简单的很基本的 HTTP(1.1) 协议的编、解码，完全可以使用 HTTP 协议搭建一个 RPC 服务。</li>
<li>TinyPB 协议: 一种基于 <b>Protobuf</b> 的自定义协议，属于二进制协议。</li>
</ol>
<h2><a class="anchor" id="autotoc_md10"></a>
1.3. TinyRPC 的 RPC 调用</h2>
<p>TinyRPC 是一款异步的 RPC 框架，这就意味着服务之前的调用是非常高效的。目前来说，TinyRPC 支持两种RPC 调用方式：**阻塞协程式异步调用** 和 **非阻塞协程式异步调用**。</p>
<h3><a class="anchor" id="autotoc_md11"></a>
1.3.1. 阻塞协程式异步调用</h3>
<p>阻塞协程式异步调用这个名字看上去很奇怪，阻塞像是很低效的做法。然而其实他是非常高效的。他的思想是**用同步的代码，实现异步的性能。** 也就是说，**TinyRPC** 在 RPC 调用时候不需要像其他异步操作一样需要写复杂的回调函数，只需要直接调用即可。这看上去是同步的过程，实际上由于内部的协程封装实现了完全的异步。而作为外层的使用者完全不必关系这些琐碎的细节。</p>
<p>阻塞协程式异步调用对应 TinyPbRpcChannel 类，一个简单的调用例子如下：</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">tinyrpc::TinyPbRpcChannel channel(std::make_shared&lt;tinyrpc::IPAddress&gt;(&quot;127.0.0.1&quot;, 39999));</div>
<div class="line">QueryService_Stub stub(&amp;channel);</div>
<div class="line"> </div>
<div class="line">tinyrpc::TinyPbRpcController rpc_controller;</div>
<div class="line">rpc_controller.SetTimeout(10000);</div>
<div class="line"> </div>
<div class="line">DebugLog &lt;&lt; &quot;RootHttpServlet begin to call RPC&quot; &lt;&lt; count;</div>
<div class="line">stub.query_name(&amp;rpc_controller, &amp;rpc_req, &amp;rpc_res, NULL);</div>
<div class="line">DebugLog &lt;&lt; &quot;RootHttpServlet end to call RPC&quot; &lt;&lt; count;</div>
</div><!-- fragment --><p>这看上去跟普通的阻塞式调用没什么区别，然而实际上在 stub.query_name 这一行是完全异步的，简单来说。线程不会阻塞在这一行，而会转而去处理其他协程，只有当数据返回就绪时，query_name 函数自动返回，继续下面的操作。 这个过程的执行流如图所示：</p>
<p><img src="./imgs/block_async_call.drawio.png" alt="" class="inline"/></p>
<p>从图中可以看出，在调用 query_name 到 query_name 返回这段时间 T，CPU 的执行权已经完全移交给主协程了，也就说是这段时间主协程可以用来做任何事情：包括响应客户端请求、执行定时任务、陷入 epoll_wait 等待事件就绪等。对单个协程来说，它的执行流被阻塞了。但对于整个线程来说是完全没有被阻塞，它始终在执行着任务。</p>
<p>另外这个过程完全没有注册回调函数、另起线程之类的操作，可它确确实实达到异步了。这也是 <b>TinyRPC</b> 的核心思想之一。</p>
<p>这种调用方式是 TinyRPC 推荐的方式，它的优点如下：</p><ol type="1">
<li>代码实现很简单，直接同步式调用，不需要写回调函数。</li>
<li>对IO线程数没有限制，**即使只有 1 个 IO 线程**，仍然能达到这种效果。</li>
<li>对于线程来说，他是**不会阻塞线程**的。</li>
</ol>
<p>当然，它的缺点也存在：</p><ol type="1">
<li>对于**当前协程来说，他是阻塞的**，必须等待协程再次被唤醒（**RESUME**）才能执行下面的代码。</li>
</ol>
<h3><a class="anchor" id="autotoc_md12"></a>
1.3.2. 非阻塞协程式异步调用</h3>
<p><b>非阻塞协程式异步调用**是 TinyRPC 支持的另一种 RPC 调用方式，它解决了**阻塞协程式异步调用</b> 的一些缺点，当然也同时引入了一些限制。这种方式有点类似于 C++11 的 future 特性, 但也不完全一样。</p>
<p>非阻塞协程式异步调用对应 TinyPbRpcAsyncChannel，一个简单调用例子如下：</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">{</div>
<div class="line">  std::shared_ptr&lt;queryAgeReq&gt; rpc_req = std::make_shared&lt;queryAgeReq&gt;();</div>
<div class="line">  std::shared_ptr&lt;queryAgeRes&gt; rpc_res = std::make_shared&lt;queryAgeRes&gt;();</div>
<div class="line">  AppDebugLog &lt;&lt; &quot;now to call QueryServer TinyRPC server to query who&#39;s id is &quot; &lt;&lt; req-&gt;m_query_maps[&quot;id&quot;];</div>
<div class="line">  rpc_req-&gt;set_id(std::atoi(req-&gt;m_query_maps[&quot;id&quot;].c_str()));</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  std::shared_ptr&lt;tinyrpc::TinyPbRpcController&gt; rpc_controller = std::make_shared&lt;tinyrpc::TinyPbRpcController&gt;();</div>
<div class="line">  rpc_controller-&gt;SetTimeout(10000);</div>
<div class="line"> </div>
<div class="line">  tinyrpc::IPAddress::ptr addr = std::make_shared&lt;tinyrpc::IPAddress&gt;(&quot;127.0.0.1&quot;, 39999);</div>
<div class="line"> </div>
<div class="line">  tinyrpc::TinyPbRpcAsyncChannel::ptr async_channel = </div>
<div class="line">    std::make_shared&lt;tinyrpc::TinyPbRpcAsyncChannel&gt;(addr);</div>
<div class="line"> </div>
<div class="line">  async_channel-&gt;saveCallee(rpc_controller, rpc_req, rpc_res, nullptr);</div>
<div class="line"> </div>
<div class="line">  QueryService_Stub stub(async_channel.get());</div>
<div class="line">  stub.query_age(rpc_controller.get(), rpc_req.get(), rpc_res.get(), NULL);</div>
<div class="line">}</div>
</div><!-- fragment --><p>注意在这种调用方式中，query_age 会立马返回，协程 C1 可以继续执行下面的代码。但这并不代表着调用 RPC 完成，如果你需要获取调用结果，请使用: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">async_channel-&gt;wait();</div>
</div><!-- fragment --><p> 此时协程 C1 会阻塞直到异步 RPC 调用完成，注意只会阻塞当前协程 C1，而不是当前线程(其实调用 wait 后就相当于把当前协程 C1 Yiled 了，等待 RPC 完成后自动 Resume)。</p>
<p>当然，wait() 是可选的。如果你不关心调用结果，完全可以不调用 wait。即相当于一个**异步的任务队列**。</p>
<p>这种调用方式的原理很简单，会新生成一个协程 C2 去处理这次 RPC 调用，把这个协程 C2 加入调度池任务里面，而原来的协程 C1 可以继续往下执行。</p>
<p>新协程 C2 会在适当的时候被IO线程调度（可能是IO线程池里面任意一个 IO线程）, 当 RPC 调用完成后，会唤醒原协程 C1 通知调用完成(前提是 C1 中调用了 wait 等待结果)。</p>
<p>这个调用链路如图：</p>
<p><img src="./imgs/nonblock_async_call.drawio.png" alt="" class="inline"/></p>
<p>总之，非阻塞协程式异步调用的优点如下：</p><ol type="1">
<li>RPC 调用不阻塞当前协程 C1，C1 可以继续往下执行代码(若遇到 wait 则会阻塞)。</li>
</ol>
<p>而缺点如下：</p><ol type="1">
<li>所有 RPC 调用相关的对象，**必须是堆上的对象，而不是栈对象**， 包括 req、res、controller、async_rpc_channel。强烈推荐使用 shared_ptr，否则可能会有意想不到的问题(基本是必须使用了)。</li>
<li>在 RPC 调用前必须调用 TinyPbRpcAsyncChannel::saveCallee(), 提前预留资源的引用计数。实际上是第1点的补充，相当于强制要求使用 shared_ptr 了。</li>
</ol>
<p>解释一下第一点：调用相关的对象是在线程 A 中声明的，但由于是异步 RPC 调用，整个调用过程是又另外一个线程 B 执行的。因此你必须确保当线程 B 在这些 RPC 调用的时候，这些对象还存在，即没有被销毁。 那为什么不能是栈对象？想像一下，假设你在某个函数中异步调用 RPC，如果这些对象都是栈对象，那么当函数结束时这些栈对象自动被销毁了，线程 B 此时显然会 coredump 掉。因此请在堆上申请对象。另外，推荐使用 shared_ptr 是因为 TinyPbRpcAsyncChannel 内部已经封装好细节了，当异步 RPC 完成之后会自动销毁对象，你不必担心内存泄露的问题！</p>
<h1><a class="anchor" id="autotoc_md13"></a>
2. 性能测试</h1>
<p>TinyRPC 底层使用的是 Reactor 架构，同时又结合了多线程，其性能是能得到保障的。进行几个简单的性能测试结果如下： </p>
<h2><a class="anchor" id="autotoc_md14"></a>
2.1. HTTP echo 测试 QPS</h2>
<p>测试机配置信息：Centos**虚拟机**，内存**6G**，CPU为**4核**</p>
<p>测试工具：**wrk**: <a href="https://github.com/wg/wrk.git">https://github.com/wg/wrk.git</a></p>
<p>部署信息：wrk 与 TinyRPC 服务部署在同一台虚拟机上, 关闭 TinyRPC 日志</p>
<p>测试命令： </p><div class="fragment"><div class="line">// -c 为并发连接数，按照表格数据依次修改</div>
<div class="line">wrk -c 1000 -t 8 -d 30 --latency &#39;http://127.0.0.1:19999/qps?id=1&#39;</div>
</div><!-- fragment --><p>测试结果： </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>QPS</b>   </th><th class="markdownTableHeadNone"><b>WRK 并发连接 1000</b>   </th><th class="markdownTableHeadNone"><b>WRK 并发连接 2000</b>   </th><th class="markdownTableHeadNone"><b>WRK 并发连接 5000</b>   </th><th class="markdownTableHeadNone"><b>WRK 并发连接 10000</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IO线程数为 <b>1</b>   </td><td class="markdownTableBodyNone"><b>27000 QPS</b>   </td><td class="markdownTableBodyNone"><b>26000 QPS</b>   </td><td class="markdownTableBodyNone"><b>20000 QPS</b>   </td><td class="markdownTableBodyNone"><b>20000 QPS</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IO线程数为 <b>4</b>   </td><td class="markdownTableBodyNone"><b>140000 QPS</b>   </td><td class="markdownTableBodyNone"><b>130000 QPS</b>   </td><td class="markdownTableBodyNone"><b>123000 QPS</b>   </td><td class="markdownTableBodyNone"><b>118000 QPS</b>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">IO线程数为 <b>8</b>   </td><td class="markdownTableBodyNone"><b>135000 QPS</b>   </td><td class="markdownTableBodyNone"><b>120000 QPS</b>   </td><td class="markdownTableBodyNone"><b>100000 QPS</b>   </td><td class="markdownTableBodyNone"><b>100000 QPS</b>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">IO线程数为 <b>16</b>   </td><td class="markdownTableBodyNone"><b>125000 QPS</b>   </td><td class="markdownTableBodyNone"><b>127000 QPS</b>   </td><td class="markdownTableBodyNone"><b>123000 QPS</b>   </td><td class="markdownTableBodyNone"><b>118000 QPS</b>   </td></tr>
</table>
<div class="fragment"><div class="line">// IO 线程为 4, 并发连接 1000 的测试结果</div>
<div class="line">[ikerli@localhost bin]$ wrk -c 1000 -t 8 -d 30 --latency &#39;http://127.0.0.1:19999/qps?id=1&#39;</div>
<div class="line">Running 30s test @ http://127.0.0.1:19999/qps?id=1</div>
<div class="line">  8 threads and 1000 connections</div>
<div class="line">  Thread Stats   Avg      Stdev     Max   +/- Stdev</div>
<div class="line">    Latency     9.79ms   63.83ms   1.68s    99.24%</div>
<div class="line">    Req/Sec    17.12k     8.83k   97.54k    72.61%</div>
<div class="line">  Latency Distribution</div>
<div class="line">     50%    4.37ms</div>
<div class="line">     75%    7.99ms</div>
<div class="line">     90%   11.65ms</div>
<div class="line">     99%   27.13ms</div>
<div class="line">  4042451 requests in 30.07s, 801.88MB read</div>
<div class="line">  Socket errors: connect 0, read 0, write 0, timeout 205</div>
<div class="line">Requests/sec: 134442.12</div>
<div class="line">Transfer/sec:     26.67MB</div>
</div><!-- fragment --><p>由以上测试结果，**TinyRPC 框架的 QPS 可达到 14W 左右**。</p>
<h1><a class="anchor" id="autotoc_md15"></a>
3. 安装 TinyRPC</h1>
<h2><a class="anchor" id="autotoc_md16"></a>
3.1. 安装必要的依赖库</h2>
<p>要正确编译 <b>TinyRPC</b>, 至少要先安装这几个库：</p>
<h3><a class="anchor" id="autotoc_md17"></a>
3.1.1. protobuf</h3>
<p><b>protobuf</b> 是 <b>google</b> 开源的有名的序列化库。谷歌出品，必属精品！**TinyRPC** 的 <b>TinyPB</b> 协议是基于 protobuf 来 序列化/反序列化 的，因此这个库是必须的。 其地址为：https://github.com/protocolbuffers/protobuf</p>
<p>推荐安装版本 <b>3.19.4</b> 及以上。安装过程不再赘述, <b>注意将头文件和库文件 copy 到对应的系统路径下。</b></p>
<h3><a class="anchor" id="autotoc_md18"></a>
3.1.2. tinyxml</h3>
<p>由于 <b>TinyRPC</b> 读取配置使用了 <b>xml</b> 文件，因此需要安装 <b>tinyxml</b> 库来解析配置文件。</p>
<p>下载地址：https://sourceforge.net/projects/tinyxml/</p>
<p>要生成 libtinyxml.a 静态库，需要简单修改 makefile 如下: </p><div class="fragment"><div class="line"># 84 行修改为如下</div>
<div class="line">OUTPUT := libtinyxml.a </div>
<div class="line"> </div>
<div class="line"># 194, 105 行修改如下</div>
<div class="line">${OUTPUT}: ${OBJS}</div>
<div class="line">    ${AR} $@ ${LDFLAGS} ${OBJS} ${LIBS} ${EXTRA_LIBS}</div>
</div><!-- fragment --><p> 安装过程如下： </p><div class="fragment"><div class="line">cd tinyxml</div>
<div class="line">make -j4</div>
<div class="line"> </div>
<div class="line"># copy 库文件到系统库文件搜索路径下</div>
<div class="line">cp libtinyxml.a /usr/lib/</div>
<div class="line"> </div>
<div class="line"># copy 头文件到系统头文件搜索路径下 </div>
<div class="line">mkdir /usr/include/tinyxml</div>
<div class="line">cp *.h /usr/include/tinyxml</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
3.2. 安装和卸载</h2>
<h3><a class="anchor" id="autotoc_md20"></a>
3.2.1. 安装 TinyRPC</h3>
<p>在安装了前置的几个库之后，就可以开始编译和安装 <b>TinyRPC</b> 了。安装过程十分简单，只要不出什么意外就好了。</p>
<p>**祈祷**一下一次性成功，然后直接执行以下几个命令即可： </p><div class="fragment"><div class="line">git clone https://github.com/Gooddbird/tinyrpc</div>
<div class="line"> </div>
<div class="line">cd tinyrpc</div>
<div class="line"> </div>
<div class="line">mkdir bin &amp;&amp; mkdir lib &amp;&amp; mkdir obj</div>
<div class="line"> </div>
<div class="line">// 生成测试pb桩文件</div>
<div class="line">cd testcases</div>
<div class="line">protoc --cpp_out=./ test_tinypb_server.proto</div>
<div class="line"> </div>
<div class="line">cd ..</div>
<div class="line">// 先执行编译</div>
<div class="line">make -j4</div>
<div class="line"> </div>
<div class="line">// 编译成功后直接安装就行了</div>
<div class="line">make install</div>
</div><!-- fragment --><p>注意, make install 完成后，默认会在 **/usr/lib** 路径下安装 <b>libtinyrpc.a</b> 静态库文件，以及在 **/usr/include/tinyrpc** 下安装所有的头文件。</p>
<p>如果编译出现问题，欢迎提 <a href="https://github.com/Gooddbird/tinyrpc/issues/">issue</a>, 我会尽快回应。</p>
<h3><a class="anchor" id="autotoc_md21"></a>
3.2.2. 卸载 TinyRPC</h3>
<p>卸载也很简单，如下即可： </p><div class="fragment"><div class="line">make uninstall</div>
</div><!-- fragment --><p> <b>注：如果此前已经安装过 TinyRPC, 建议先执行卸载命令后再重新 make install 安装.</b></p>
<h1><a class="anchor" id="autotoc_md22"></a>
4. 快速上手</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
4.1. 搭建基于 TinyPB 协议的 RPC 服务</h2>
<h3><a class="anchor" id="autotoc_md24"></a>
4.1.1. 实现 Protobuf 文件接口</h3>
<p>TinyPB 协议基于 Protobuf 来序列化的，在搭建基于 TinyPB 协议的 RPC 服务之前，需要先定义接口文档。具体的 Protobuf 文档需要根据业务的实际功能来编写，这里给出一个例子如下: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// test_tinypb_server.proto</div>
<div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line">option cc_generic_services = true;</div>
<div class="line"> </div>
<div class="line">message queryAgeReq {</div>
<div class="line">  int32 req_no = 1;</div>
<div class="line">  int32 id = 2;</div>
<div class="line">}</div>
<div class="line">message queryAgeRes {</div>
<div class="line">  int32 ret_code = 1;</div>
<div class="line">  string res_info = 2;</div>
<div class="line">  int32 req_no = 3;</div>
<div class="line">  int32 id = 4;</div>
<div class="line">  int32 age = 5;</div>
<div class="line">}</div>
<div class="line">message queryNameReq {</div>
<div class="line">  int32 req_no = 1;</div>
<div class="line">  int32 id = 2;</div>
<div class="line">  int32 type = 3;</div>
<div class="line">}</div>
<div class="line">message queryNameRes {</div>
<div class="line">  int32 ret_code = 1;</div>
<div class="line">  string res_info = 2;</div>
<div class="line">  int32 req_no = 3;</div>
<div class="line">  int32 id = 4;</div>
<div class="line">  string name = 5;</div>
<div class="line">}</div>
<div class="line">service QueryService {</div>
<div class="line">  // rpc method name</div>
<div class="line">  rpc query_name(queryNameReq) returns (queryNameRes);</div>
<div class="line"> </div>
<div class="line">  // rpc method name</div>
<div class="line">  rpc query_age(queryAgeReq) returns (queryAgeRes);</div>
<div class="line">}</div>
</div><!-- fragment --><p> 使用 protoc 工具生成对应的 C++ 代码： </p><div class="fragment"><div class="line">protoc --cpp_out=./ test_tinypb_server.proto</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md25"></a>
4.1.2. 准备配置文件</h3>
<p><b>TinyRPC</b> 读取标准的 <b>xml</b> 配置文件完成一些服务初始化设置，这个配置文件模板如下，一般只需要按需调整参数即可： </p><div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span> ?&gt;</div>
<div class="line">&lt;<span class="keywordtype">root</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!--log config--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">log</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--identify path of log file--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_path</span>&gt;./&lt;/<span class="keywordtype">log_path</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">log_prefix</span>&gt;<span class="keyword">test_tinypb_server</span>&lt;/<span class="keywordtype">log_prefix</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--identify max size of single log file, MB--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_max_file_size</span>&gt;5&lt;/<span class="keywordtype">log_max_file_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--log level: DEBUG &lt; INFO &lt; WARN &lt; ERROR--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">rpc_log_level</span>&gt;<span class="keyword">DEBUG</span>&lt;/<span class="keywordtype">rpc_log_level</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">app_log_level</span>&gt;<span class="keyword">DEBUG</span>&lt;/<span class="keywordtype">app_log_level</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--inteval that put log info to async logger, ms--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_sync_inteval</span>&gt;500&lt;/<span class="keywordtype">log_sync_inteval</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">log</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">coroutine</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--coroutine stack size (KB)--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">coroutine_stack_size</span>&gt;256&lt;/<span class="keywordtype">coroutine_stack_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--default coroutine pool size--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">coroutine_pool_size</span>&gt;1000&lt;/<span class="keywordtype">coroutine_pool_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;/<span class="keywordtype">coroutine</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">msg_req_len</span>&gt;20&lt;/<span class="keywordtype">msg_req_len</span>&gt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">&lt;!--max time when call connect, s--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">max_connect_timeout</span>&gt;75&lt;/<span class="keywordtype">max_connect_timeout</span>&gt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">&lt;!--count of io threads, at least 1--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">iothread_num</span>&gt;8&lt;/<span class="keywordtype">iothread_num</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">time_wheel</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">bucket_num</span>&gt;6&lt;/<span class="keywordtype">bucket_num</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--inteval that destroy bad TcpConnection, s--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">inteval</span>&gt;10&lt;/<span class="keywordtype">inteval</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">time_wheel</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">server</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">ip</span>&gt;127.0.0.1&lt;/<span class="keywordtype">ip</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">port</span>&gt;39999&lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--注意这里选择 TinyPB 协议--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">protocal</span>&gt;<span class="keyword">TinyPB</span>&lt;/<span class="keywordtype">protocal</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">server</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">root</span>&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md26"></a>
4.1.3. 实现业务接口</h3>
<p>protobuf 文件提供的只是接口说明，而实际的业务逻辑需要自己实现。只需要继承 <a class="el" href="classQueryService.html">QueryService</a> 并重写方法即可，例如： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// test_tinypb_server.cc</div>
<div class="line">class QueryServiceImpl : public QueryService {</div>
<div class="line"> public:</div>
<div class="line">  QueryServiceImpl() {}</div>
<div class="line">  ~QueryServiceImpl() {}</div>
<div class="line"> </div>
<div class="line">  void query_age(google::protobuf::RpcController* controller,</div>
<div class="line">                       const ::queryAgeReq* request,</div>
<div class="line">                       ::queryAgeRes* response,</div>
<div class="line">                       ::google::protobuf::Closure* done) {</div>
<div class="line"> </div>
<div class="line">    AppInfoLog &lt;&lt; &quot;QueryServiceImpl.query_age, req={&quot;&lt;&lt; request-&gt;ShortDebugString() &lt;&lt; &quot;}&quot;;</div>
<div class="line"> </div>
<div class="line">    response-&gt;set_ret_code(0);</div>
<div class="line">    response-&gt;set_res_info(&quot;OK&quot;);</div>
<div class="line">    response-&gt;set_req_no(request-&gt;req_no());</div>
<div class="line">    response-&gt;set_id(request-&gt;id());</div>
<div class="line">    response-&gt;set_age(100100111);</div>
<div class="line"> </div>
<div class="line">    if (done) {</div>
<div class="line">      done-&gt;Run();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    AppInfoLog &lt;&lt; &quot;QueryServiceImpl.query_age, res={&quot;&lt;&lt; response-&gt;ShortDebugString() &lt;&lt; &quot;}&quot;;</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md27"></a>
4.1.4. 启动 RPC 服务</h3>
<p>TinyRPC 服务启动非常简单，只需寥寥几行代码即可： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">int main(int argc, char* argv[]) {</div>
<div class="line">  if (argc != 2) {</div>
<div class="line">    printf(&quot;Start TinyRPC server error, input argc is not 2!&quot;);</div>
<div class="line">    printf(&quot;Start TinyRPC server like this: \n&quot;);</div>
<div class="line">    printf(&quot;./server a.xml\n&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // 1. 读取配置文件</div>
<div class="line">  tinyrpc::InitConfig(argv[1]);</div>
<div class="line">  // 2. 注册 service</div>
<div class="line">  REGISTER_SERVICE(QueryServiceImpl);</div>
<div class="line">  // 3. 启动 RPC 服务</div>
<div class="line">  tinyrpc::StartRpcServer();</div>
<div class="line">  </div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> 生成可执行文件 <b>test_tinypb_server</b> 后，启动命令如下： </p><div class="fragment"><div class="line">nohup ./test_tinypb_server ../conf/test_tinypb_server.xml &amp;</div>
</div><!-- fragment --><p> 如果没什么报错信息，那么恭喜你启动成功了。如果不放心，可以使用 ps 命令查看进程是否存在：</p>
<div class="fragment"><div class="line">ps -elf | grep &#39;test_tinypb_server&#39;</div>
</div><!-- fragment --><p> 或者使用 netstat 命令查看端口是否被监听： </p><div class="fragment"><div class="line">netstat -tln | grep 39999</div>
</div><!-- fragment --><p> 至此，基于 TinyPB 协议的 RPC 服务已经启动成功，后续我们将调用这个服务。</p>
<h2><a class="anchor" id="autotoc_md28"></a>
4.2. 搭建基于 HTTP 协议的 RPC 服务</h2>
<h3><a class="anchor" id="autotoc_md29"></a>
4.2.1. 准备配置文件</h3>
<p>同上，准备一个配置文件 <b>test_http_server.xml</b>: </p><div class="fragment"><div class="line">&lt;?<span class="keyword">xml</span> <span class="keyword">version</span>=<span class="stringliteral">&quot;1.0&quot;</span> <span class="keyword">encoding</span>=<span class="stringliteral">&quot;UTF-8&quot;</span> ?&gt;</div>
<div class="line">&lt;<span class="keywordtype">root</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!--log config--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">log</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--identify path of log file--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_path</span>&gt;./&lt;/<span class="keywordtype">log_path</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">log_prefix</span>&gt;<span class="keyword">test_http_server</span>&lt;/<span class="keywordtype">log_prefix</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--identify max size of single log file, MB--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_max_file_size</span>&gt;5&lt;/<span class="keywordtype">log_max_file_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--log level: DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; NONE(don&#39;t print log)--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">rpc_log_level</span>&gt;<span class="keyword">DEBUG</span>&lt;/<span class="keywordtype">rpc_log_level</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">app_log_level</span>&gt;<span class="keyword">DEBUG</span>&lt;/<span class="keywordtype">app_log_level</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--inteval that put log info to async logger, ms--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">log_sync_inteval</span>&gt;500&lt;/<span class="keywordtype">log_sync_inteval</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">log</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">coroutine</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--coroutine stack size (KB)--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">coroutine_stack_size</span>&gt;128&lt;/<span class="keywordtype">coroutine_stack_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--default coroutine pool size--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">coroutine_pool_size</span>&gt;1000&lt;/<span class="keywordtype">coroutine_pool_size</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;/<span class="keywordtype">coroutine</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">msg_req_len</span>&gt;20&lt;/<span class="keywordtype">msg_req_len</span>&gt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">&lt;!--max time when call connect, s--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">max_connect_timeout</span>&gt;75&lt;/<span class="keywordtype">max_connect_timeout</span>&gt;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">&lt;!--count of io threads, at least 1--&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">iothread_num</span>&gt;4&lt;/<span class="keywordtype">iothread_num</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">time_wheel</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">bucket_num</span>&gt;3&lt;/<span class="keywordtype">bucket_num</span>&gt;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">&lt;!--inteval that destroy bad TcpConnection, s--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">inteval</span>&gt;10&lt;/<span class="keywordtype">inteval</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">time_wheel</span>&gt;</div>
<div class="line"> </div>
<div class="line">  &lt;<span class="keywordtype">server</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">ip</span>&gt;127.0.0.1&lt;/<span class="keywordtype">ip</span>&gt;</div>
<div class="line">    &lt;<span class="keywordtype">port</span>&gt;19999&lt;/<span class="keywordtype">port</span>&gt;</div>
<div class="line">    <span class="comment">&lt;!--这里选择 HTTP--&gt;</span></div>
<div class="line">    &lt;<span class="keywordtype">protocal</span>&gt;<span class="keyword">HTTP</span>&lt;/<span class="keywordtype">protocal</span>&gt;</div>
<div class="line">  &lt;/<span class="keywordtype">server</span>&gt;</div>
<div class="line"> </div>
<div class="line">&lt;/<span class="keywordtype">root</span>&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md30"></a>
4.2.2. 实现 Servlet 接口</h3>
<p><b>TinyRPC</b> 提供类似 JAVA 的 <b>Servlet</b> 接口来实现 HTTP 服务。你只需要简单的继承 HttpServlet 类并实现 handle 方法即可，如一个 HTTP 的 echo 如下： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// test_http_server.cc</div>
<div class="line">class QPSHttpServlet : public tinyrpc::HttpServlet {</div>
<div class="line"> public:</div>
<div class="line">  QPSHttpServlet() = default;</div>
<div class="line">  ~QPSHttpServlet() = default;</div>
<div class="line"> </div>
<div class="line">  void handle(tinyrpc::HttpRequest* req, tinyrpc::HttpResponse* res) {</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;QPSHttpServlet get request&quot;;</div>
<div class="line">    setHttpCode(res, tinyrpc::HTTP_OK);</div>
<div class="line">    setHttpContentType(res, &quot;text/html;charset=utf-8&quot;);</div>
<div class="line"> </div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; &quot;QPSHttpServlet Echo Success!! Your id is,&quot; &lt;&lt; req-&gt;m_query_maps[&quot;id&quot;];</div>
<div class="line">    char buf[512];</div>
<div class="line">    sprintf(buf, html, ss.str().c_str());</div>
<div class="line">    setHttpBody(res, std::string(buf));</div>
<div class="line">    AppDebugLog &lt;&lt; ss.str();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string getServletName() {</div>
<div class="line">    return &quot;QPSHttpServlet&quot;;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md31"></a>
4.2.3. 启动 RPC 服务</h3>
<p>将 Servlet 注册到路径下，启动 RPC 服务即可。注意这个注册路径相对于项目的根路径而言： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// test_http_server.cc</div>
<div class="line">int main(int argc, char* argv[]) {</div>
<div class="line">  if (argc != 2) {</div>
<div class="line">    printf(&quot;Start TinyRPC server error, input argc is not 2!&quot;);</div>
<div class="line">    printf(&quot;Start TinyRPC server like this: \n&quot;);</div>
<div class="line">    printf(&quot;./server a.xml\n&quot;);</div>
<div class="line">    return 0;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  tinyrpc::InitConfig(argv[1]);</div>
<div class="line"> </div>
<div class="line">  // 访问 http://127.0.0.1:19999/qps, 即对应 QPSHttpServlet 这个接口</div>
<div class="line">  REGISTER_HTTP_SERVLET(&quot;/qps&quot;, QPSHttpServlet);</div>
<div class="line">  tinyrpc::StartRpcServer();</div>
<div class="line">  return 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> 启动命令同样如下： </p><div class="fragment"><div class="line">nohup ./test_http_server ../conf/test_http_server.xml &amp;</div>
</div><!-- fragment --><p> 使用 curl 工具可以测试 HTTP 服务是否启动成功： </p><div class="fragment"><div class="line">[ikerli@localhost bin]$ curl -X GET &#39;http://127.0.0.1:19999/qps?id=1&#39;</div>
<div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome to TinyRPC, just enjoy it!&lt;/h1&gt;&lt;p&gt;QPSHttpServlet Echo Success!! Your id is,1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md32"></a>
4.3. RPC 服务调用</h2>
<p>这一节将使用 test_http_server 服务调用 test_rpc_server，前面说过，TinyRPC 支持两种 RPC 调用方式：**阻塞协程式异步调用** 和 <b>非阻塞协程式异步调用</b></p>
<h3><a class="anchor" id="autotoc_md33"></a>
4.3.1. 阻塞协程式异步调用</h3>
<p>这种调用方式适用于我们依赖 RPC 调用结果的场景，必须等待 RPC 调用返回后才能进行下一步业务处理。BlockHttpServlet 即属于这种调用方式： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">class BlockCallHttpServlet : public tinyrpc::HttpServlet {</div>
<div class="line"> public:</div>
<div class="line">  BlockCallHttpServlet() = default;</div>
<div class="line">  ~BlockCallHttpServlet() = default;</div>
<div class="line"> </div>
<div class="line">  void handle(tinyrpc::HttpRequest* req, tinyrpc::HttpResponse* res) {</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;BlockCallHttpServlet get request &quot;;</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;BlockCallHttpServlet success recive http request, now to get http response&quot;;</div>
<div class="line">    setHttpCode(res, tinyrpc::HTTP_OK);</div>
<div class="line">    setHttpContentType(res, &quot;text/html;charset=utf-8&quot;);</div>
<div class="line"> </div>
<div class="line">    queryAgeReq rpc_req;</div>
<div class="line">    queryAgeRes rpc_res;</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;now to call QueryServer TinyRPC server to query who&#39;s id is &quot; &lt;&lt; req-&gt;m_query_maps[&quot;id&quot;];</div>
<div class="line">    rpc_req.set_id(std::atoi(req-&gt;m_query_maps[&quot;id&quot;].c_str()));</div>
<div class="line"> </div>
<div class="line">    // 初始化 TinyPbRpcChannel 对象</div>
<div class="line">    tinyrpc::TinyPbRpcChannel channel(std::make_shared&lt;tinyrpc::IPAddress&gt;(&quot;127.0.0.1&quot;, 39999));</div>
<div class="line">    QueryService_Stub stub(&amp;channel);</div>
<div class="line"> </div>
<div class="line">    // 初始化 TinyPbRpcController 对象, 设置超时时间等</div>
<div class="line">    tinyrpc::TinyPbRpcController rpc_controller;</div>
<div class="line">    rpc_controller.SetTimeout(5000);</div>
<div class="line"> </div>
<div class="line">    AppDebugLog &lt;&lt; &quot;BlockCallHttpServlet end to call RPC&quot;;</div>
<div class="line">    // 进行 RRC 调用， 这一步会阻塞当前协程，直到调用完成返回</div>
<div class="line">    // 当然阻塞的只是当前协程，对线程来说完全可以去执行其他的协程，因此不会影响性能</div>
<div class="line">    stub.query_age(&amp;rpc_controller, &amp;rpc_req, &amp;rpc_res, NULL);</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;BlockCallHttpServlet end to call RPC&quot;;</div>
<div class="line">    // 判断是否有框架级错误</div>
<div class="line">    if (rpc_controller.ErrorCode() != 0) {</div>
<div class="line">      AppDebugLog &lt;&lt; &quot;failed to call QueryServer rpc server&quot;;</div>
<div class="line">      char buf[512];</div>
<div class="line">      sprintf(buf, html, &quot;failed to call QueryServer rpc server&quot;);</div>
<div class="line">      setHttpBody(res, std::string(buf));</div>
<div class="line">      return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    if (rpc_res.ret_code() != 0) {</div>
<div class="line">      std::stringstream ss;</div>
<div class="line">      ss &lt;&lt; &quot;QueryServer rpc server return bad result, ret = &quot; &lt;&lt; rpc_res.ret_code() &lt;&lt; &quot;, and res_info = &quot; &lt;&lt; rpc_res.res_info();</div>
<div class="line">      AppDebugLog &lt;&lt; ss.str();</div>
<div class="line">      char buf[512];</div>
<div class="line">      sprintf(buf, html, ss.str().c_str());</div>
<div class="line">      setHttpBody(res, std::string(buf));</div>
<div class="line">      return;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; &quot;Success!! Your age is,&quot; &lt;&lt; rpc_res.age() &lt;&lt; &quot; and Your id is &quot; &lt;&lt; rpc_res.id();</div>
<div class="line"> </div>
<div class="line">    char buf[512];</div>
<div class="line">    sprintf(buf, html, ss.str().c_str());</div>
<div class="line">    setHttpBody(res, std::string(buf));</div>
<div class="line"> </div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string getServletName() {</div>
<div class="line">    return &quot;BlockCallHttpServlet&quot;;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> 注册此 Servlet, 然后重启 <b>test_http_server</b> </p><div class="fragment"><div class="line">REGISTER_HTTP_SERVLET(&quot;/block&quot;, BlockCallHttpServlet);</div>
</div><!-- fragment --><p> 使用 curl 测试 </p><div class="fragment"><div class="line">[ikerli@localhost bin]$ curl -X GET &#39;http://127.0.0.1:19999/block?id=1&#39;</div>
<div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome to TinyRPC, just enjoy it!&lt;/h1&gt;&lt;p&gt;Success!! Your age is,100100111 and Your id is 1&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md34"></a>
4.3.2. 非阻塞协程式异步调用</h3>
<p>这种调用方式适用于我们不依赖 RPC 调用结果的场景，即我们可以继续业务处理，而不关心何时 RPC 调用成功。NonBlockHttpServlet 即属于这种调用方式： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">class NonBlockCallHttpServlet: public tinyrpc::HttpServlet {</div>
<div class="line"> public:</div>
<div class="line">  NonBlockCallHttpServlet() = default;</div>
<div class="line">  ~NonBlockCallHttpServlet() = default;</div>
<div class="line"> </div>
<div class="line">  void handle(tinyrpc::HttpRequest* req, tinyrpc::HttpResponse* res) {</div>
<div class="line">    AppInfoLog &lt;&lt; &quot;NonBlockCallHttpServlet get request&quot;;</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;NonBlockCallHttpServlet success recive http request, now to get http response&quot;;</div>
<div class="line">    setHttpCode(res, tinyrpc::HTTP_OK);</div>
<div class="line">    setHttpContentType(res, &quot;text/html;charset=utf-8&quot;);</div>
<div class="line">    // 注意所有调用相关的对象都必须是堆对象，强烈推荐使用 shared_ptr 智能指针</div>
<div class="line">    std::shared_ptr&lt;queryAgeReq&gt; rpc_req = std::make_shared&lt;queryAgeReq&gt;();</div>
<div class="line">    std::shared_ptr&lt;queryAgeRes&gt; rpc_res = std::make_shared&lt;queryAgeRes&gt;();</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;now to call QueryServer TinyRPC server to query who&#39;s id is &quot; &lt;&lt; req-&gt;m_query_maps[&quot;id&quot;];</div>
<div class="line">    rpc_req-&gt;set_id(std::atoi(req-&gt;m_query_maps[&quot;id&quot;].c_str()));</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;tinyrpc::TinyPbRpcController&gt; rpc_controller = std::make_shared&lt;tinyrpc::TinyPbRpcController&gt;();</div>
<div class="line">    rpc_controller-&gt;SetTimeout(10000);</div>
<div class="line"> </div>
<div class="line">    AppDebugLog &lt;&lt; &quot;NonBlockCallHttpServlet begin to call RPC async&quot;;</div>
<div class="line"> </div>
<div class="line">    tinyrpc::IPAddress::ptr addr = std::make_shared&lt;tinyrpc::IPAddress&gt;(&quot;127.0.0.1&quot;, 39999);</div>
<div class="line">    // 注意区别，这是使用的是 TinyPbRpcAsyncChannel, 而不是 TinyPbRpcChannel</div>
<div class="line">    tinyrpc::TinyPbRpcAsyncChannel::ptr async_channel = </div>
<div class="line">      std::make_shared&lt;tinyrpc::TinyPbRpcAsyncChannel&gt;(addr);</div>
<div class="line"> </div>
<div class="line">    auto cb = [rpc_res]() {</div>
<div class="line">      printf(&quot;call succ, res = %s\n&quot;, rpc_res-&gt;ShortDebugString().c_str());</div>
<div class="line">      AppDebugLog &lt;&lt; &quot;NonBlockCallHttpServlet async call end, res=&quot; &lt;&lt; rpc_res-&gt;ShortDebugString();</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    std::shared_ptr&lt;tinyrpc::TinyPbRpcClosure&gt; closure = std::make_shared&lt;tinyrpc::TinyPbRpcClosure&gt;(cb); </div>
<div class="line">    // 调用前必须提前保存对象，否则可能会引发段错误</div>
<div class="line">    async_channel-&gt;saveCallee(rpc_controller, rpc_req, rpc_res, closure);</div>
<div class="line"> </div>
<div class="line">    QueryService_Stub stub(async_channel.get());</div>
<div class="line">    // rpc 调用, 当前协程会继续往下执行，不依赖 RPC 调用返回</div>
<div class="line">    stub.query_age(rpc_controller.get(), rpc_req.get(), rpc_res.get(), NULL);</div>
<div class="line">    AppDebugLog &lt;&lt; &quot;NonBlockCallHttpServlet async end, now you can to some another thing&quot;;</div>
<div class="line"> </div>
<div class="line">    // 若需要等待 RPC 结果，可以使用 wait(). 当调用 wait 后，当前协程会阻塞知道 RPC 调用返回</div>
<div class="line">    // async_channel-&gt;wait();</div>
<div class="line">    // AppDebugLog &lt;&lt; &quot;wait() back, now to check is rpc call succ&quot;;</div>
<div class="line"> </div>
<div class="line">    // if (rpc_controller-&gt;ErrorCode() != 0) {</div>
<div class="line">    //   AppDebugLog &lt;&lt; &quot;failed to call QueryServer rpc server&quot;;</div>
<div class="line">    //   char buf[512];</div>
<div class="line">    //   sprintf(buf, html, &quot;failed to call QueryServer rpc server&quot;);</div>
<div class="line">    //   setHttpBody(res, std::string(buf));</div>
<div class="line">    //   return;</div>
<div class="line">    // }</div>
<div class="line"> </div>
<div class="line">    // if (rpc_res-&gt;ret_code() != 0) {</div>
<div class="line">    //   std::stringstream ss;</div>
<div class="line">    //   ss &lt;&lt; &quot;QueryServer rpc server return bad result, ret = &quot; &lt;&lt; rpc_res-&gt;ret_code() &lt;&lt; &quot;, and res_info = &quot; &lt;&lt; rpc_res-&gt;res_info();</div>
<div class="line">    //   AppDebugLog &lt;&lt; ss.str();</div>
<div class="line">    //   char buf[512];</div>
<div class="line">    //   sprintf(buf, html, ss.str().c_str());</div>
<div class="line">    //   setHttpBody(res, std::string(buf));</div>
<div class="line">    //   return;</div>
<div class="line">    // }</div>
<div class="line"> </div>
<div class="line">    std::stringstream ss;</div>
<div class="line">    ss &lt;&lt; &quot;Success!! Your age is,&quot; &lt;&lt; rpc_res-&gt;age() &lt;&lt; &quot; and Your id is &quot; &lt;&lt; rpc_res-&gt;id();</div>
<div class="line"> </div>
<div class="line">    char buf[512];</div>
<div class="line">    sprintf(buf, html, ss.str().c_str());</div>
<div class="line">    setHttpBody(res, std::string(buf));</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::string getServletName() {</div>
<div class="line">    return &quot;NonBlockCallHttpServlet&quot;;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> 注册此 Servlet, 然后重启 <b>test_http_server</b> </p><div class="fragment"><div class="line">REGISTER_HTTP_SERVLET(&quot;/nonblock&quot;, NonBlockCallHttpServlet);</div>
</div><!-- fragment --><p> 使用 curl 测试 </p><div class="fragment"><div class="line">[ikerli@localhost bin]$ curl -X GET &#39;http://127.0.0.1:19999/nonblock?id=1&#39;</div>
<div class="line">&lt;html&gt;&lt;body&gt;&lt;h1&gt;Welcome to TinyRPC, just enjoy it!&lt;/h1&gt;&lt;p&gt;Success!! Your age is,0 and Your id is 0&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
4.4. TinyRPC 脚手架(tinyrpc_generator)</h2>
<p>TinyRPC 提供了代码生成工具，简单到只需要一个 protobuf 文件，就能生成全部框架代码，作为使用者只需要写业务逻辑即可，不必关心框架的原理，也不用再去写繁琐的重复代码，以及考虑如何链接 tinyrpc 库的问题。接下来用一个实例来说明如何使用 <code>tinyrpc_generator</code>. </p>
<h3><a class="anchor" id="autotoc_md36"></a>
4.4.1 准备 protobuf 文件</h3>
<p>例如我们需要搭建一个订单服务: <code>order_server</code>. 它的提供一些简单的订单操作：查询订单、生成订单、删除订单等。 首先定义 <code>order_server.proto</code> 如下： </p><div class="fragment"><div class="line">syntax = &quot;proto3&quot;;</div>
<div class="line">option cc_generic_services = true;</div>
<div class="line"> </div>
<div class="line">message queryOrderDetailReq {</div>
<div class="line">  int32 req_no = 1;         // 请求标识,一般是唯一id</div>
<div class="line">  string order_id = 2;      // 单号</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message queryOrderDetailRsp {</div>
<div class="line">  int32 ret_code = 1;     // 返回码，0代表响应成功</div>
<div class="line">  string res_info = 2;    // 返回信息， SUCC 代表成功，否则为失败的具体信息</div>
<div class="line">  int32 req_no = 3; </div>
<div class="line">  string order_id = 4;      // 单号</div>
<div class="line">  string goods_name = 5;    // 货物名称</div>
<div class="line">  string user_name = 6;     // 用户名称</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message makeOrderReq {</div>
<div class="line">  int32 req_no = 1;</div>
<div class="line">  string user = 2;</div>
<div class="line">  string goods_name = 3;    // 货物名称</div>
<div class="line">  string pay_amount = 4;    // 支付金额</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message makeOrderRsp {</div>
<div class="line">  int32 ret_code = 1;</div>
<div class="line">  string res_info = 2;</div>
<div class="line">  int32 req_no = 3;</div>
<div class="line">  string order_id = 4;      // 订单号</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message deleteOrderReq {</div>
<div class="line">  int32 req_no = 1;         // 请求标识,一般是唯一id</div>
<div class="line">  string order_id = 2;      // 单号</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">message deleteOrderRsp {</div>
<div class="line">  int32 ret_code = 1;</div>
<div class="line">  string res_info = 2;</div>
<div class="line">  int32 req_no = 3;</div>
<div class="line">  string order_id = 4;      // 订单号</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">service OrderService {</div>
<div class="line">  // 查询订单</div>
<div class="line">  rpc query_order_detail(queryOrderDetailReq) returns (queryOrderDetailRsp);</div>
<div class="line"> </div>
<div class="line">  // 生成订单</div>
<div class="line">  rpc make_order(makeOrderReq) returns (makeOrderRsp);</div>
<div class="line"> </div>
<div class="line">  // 删除订单</div>
<div class="line">  rpc delete_order(deleteOrderReq) returns (deleteOrderRsp);</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md37"></a>
4.4.2 生成 TinyRPC 框架</h3>
<p>这一步很简单，简单到只需要一行命令： </p><div class="fragment"><div class="line">tinyrpc/generator/tinyrpc_generator.py -o ./ -i order_server.proto -p 12345</div>
</div><!-- fragment --><p> 这里先不介绍各个选项的含义，你可以观察到在当前目录下 <code>./</code> 已经生成了项目 <code>order_server</code>, 其项目结构如下： </p><div class="fragment"><div class="line">order_server: 根目录</div>
<div class="line">  - bin: 可执行文件目录</div>
<div class="line">    - run.sh: 启动脚本</div>
<div class="line">    - shutdown.sh: 停止脚本</div>
<div class="line">    - order_server: 可执行文件</div>
<div class="line">  - conf: 配置文件目录</div>
<div class="line">    - order_server.xml: TinyRPC 配置文件</div>
<div class="line">  - log: 日志目录，存放运行时产生的日志文件</div>
<div class="line">  - obj: 库文件目录，存放编译过程的中间产物</div>
<div class="line">  - order_server: 源代码文件目录</div>
<div class="line">    - comm: 公共文件</div>
<div class="line">    - interface: 接口定义文件目录，每一个RPC方法会在此处定义一个接口</div>
<div class="line">    - pb: 由 protoc 生成的文件，以及源protobuf文件</div>
<div class="line">    - service: 接口转发层，将每个 RPC 方法跳转到对应的 interface 接口</div>
<div class="line">      - order_server.cc</div>
<div class="line">      - order_server.h</div>
<div class="line">    - main.cc: main 文件，TinyRPC 服务的 main 函数在此</div>
<div class="line">    - makefile: TinyRPC 工程的 makefile 文件，直接执行 make 即可</div>
<div class="line">  - test_client: 测试工具目录，每一个 interface 下的接口，在此处都会有一个对应的 cleint 工具，可以简单测试 RPC 通信</div>
</div><!-- fragment --><p> OK, 你唯一需要做的就是进入 <code>order_server/order_server</code> 目录，执行 <code>make -j4</code> 即可，整个项目就完成构建了。</p>
<p>接下来，进入 <code>order_server/bin</code> 目录下，执行： </p><div class="fragment"><div class="line">sh run.sh order_server</div>
</div><!-- fragment --><p> 不出意外的话，你的 TinyRPC 服务已经成功的运行起来了。接下来简单测试一下，进入 <code>order_server/test_client</code> 目录，执行客户端测试工具，如： </p><div class="fragment"><div class="line">./test_query_order_detail</div>
</div><!-- fragment --><p> 如果 TinyRPC 服务启动成功，你会看到以下输出： </p><div class="fragment"><div class="line">[ikerli@localhost test_client]$ ./test_query_order_detail_client </div>
<div class="line">Send to tinyrpc server 0.0.0.0:12345, requeset body: </div>
<div class="line">Success get response frrom tinyrpc server 0.0.0.0:12345, response body: res_info: &quot;OK&quot;</div>
</div><!-- fragment --><p>否则，你会看到失败的具体原因，请根据错误码自行排查。例如这里错误显示为 peer closed，多半是服务没有启动，导致该端口没人监听。 </p><div class="fragment"><div class="line">[ikerli@localhost test_client]$ ./test_query_order_detail_client </div>
<div class="line">Send to tinyrpc server 0.0.0.0:12345, requeset body: </div>
<div class="line">Failed to call tinyrpc server, error code: 10000000, error info: connect error, peer[ 0.0.0.0:12345 ] closed.</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md38"></a>
4.4.3 业务逻辑开发</h3>
<p><code>tinyrpc_geneator</code> 为 Protobuf 文件中的每一个 rpc 方法生成了一个接口(interface), 这些接口位于 <code>order_server/interface/</code> 目录下.</p>
<p>例如这里的 <code>test_query_order_detail</code> 方法, 我们可以在 <code>interface</code> 目录下找到这两个文件： <code>query_order_detail.cc</code> 和 <code>query_order_detail.h</code> </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">// interface/query_order_detail.cc</div>
<div class="line"> </div>
<div class="line">#include &quot;tinyrpc/comm/log.h&quot;</div>
<div class="line">#include &quot;order_server/interface/query_order_detail.h&quot;</div>
<div class="line">#include &quot;order_server/pb/order_server.pb.h&quot;</div>
<div class="line"> </div>
<div class="line">namespace order_server {</div>
<div class="line"> </div>
<div class="line">QueryOrderDetailInterface::QueryOrderDetailInterface(const ::queryOrderDetailReq&amp; request, ::queryOrderDetailRsp&amp; response)</div>
<div class="line">  : m_request(request), </div>
<div class="line">  m_response(response) {</div>
<div class="line"> </div>
<div class="line">    // m_request: 客户端请求的结构体，从中可以取出请求信息</div>
<div class="line">    // m_response: 服务端响应结构体，只需要将结果设置到此即可，TinyRPC 会负责会送给客户端结果</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">QueryOrderDetailInterface::~QueryOrderDetailInterface() {</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void QueryOrderDetailInterface::run() {</div>
<div class="line">  //</div>
<div class="line">  // Run your business at here</div>
<div class="line">  // m_reponse.set_ret_code(0);</div>
<div class="line">  // m_reponse.set_res_info(&quot;Succ&quot;);</div>
<div class="line">  //</div>
<div class="line">}</div>
</div><!-- fragment --><p> 那么写业务逻辑就非常简单了，只需要实现具体的 <code>QueryOrderDetailInterface::run()</code> 方法即可，其他任何逻辑完全不需要关心,TinyRPC 已经处理好了一切。</p>
<h3><a class="anchor" id="autotoc_md39"></a>
4.4.4 Protobuf 接口升级怎么办？</h3>
<p>当需要升级接口的时候，即修改 protobuf 文件，要怎么重新生成项目呢？因为你在 <code>interface</code> 目录下实现了业务逻辑，会不会重新生成项目之后，之前的代码被覆盖了？</p>
<p>完全不用担心，<code>tinyrpc_generator</code> 已经考虑到了这种情况，你可以放心大胆的修改 protobuf 文件，然后重新执行生成命令: </p><div class="fragment"><div class="line">tinyrpc/generator/tinyrpc_generator.py -o ./ -i order_server.proto -p 12345</div>
</div><!-- fragment --><p> <code>tinyrpc_generator</code> 会智能的判断哪些文件需要更新，哪些文件无需更新。规则如下:</p><ul>
<li>interface: 下所有的接口定义文件，如果同名文件存在则不会更新，否则生成新文件</li>
<li>service: 该目录下的文件每次都会被更新，因为 protobuf 文件修改意味着接口有变化，比如新增或者删除接口之类的，需要重新生成文件以便能对新增的接口进行转发</li>
<li>makefile: 不存在时生成，存在则不更新</li>
<li>main.cc: 不存在时生成，存在则不更新</li>
<li>test_client: 不存在时生成，存在则不更新</li>
<li>pb: 每次都会更新(这是必然的，比较 protobuf 文件都变了)</li>
</ul>
<h3><a class="anchor" id="autotoc_md40"></a>
4.4.5 tinyrpc_generator 选项详解</h3>
<p><code>tinyrpc_generator</code> 是用 python 语言实现的简单脚本，其提供了几个简单的命令行入参选项，你也可以使用 <code>-h</code> 或者 <code>--help</code> 选项获取帮助文档: </p><div class="fragment"><div class="line">Options:</div>
<div class="line">-h, --help</div>
<div class="line">    打印帮助文档</div>
<div class="line">-i xxx.proto, --input xxx.proto</div>
<div class="line">    指定源 protobuf 文件，注意只支持 porotbuf3 </div>
<div class="line"> </div>
<div class="line">-o dir, --output dir</div>
<div class="line">    指定项目生成路径</div>
<div class="line"> </div>
<div class="line">-p port, --input port</div>
<div class="line">    指定 TinyRPC 服务监听的端口(默认是 39999)</div>
<div class="line"> </div>
<div class="line">-h x.x.x.x, --host x.x.x.x</div>
<div class="line">    指定 TinyRPC 服务绑定的 IP 地址(默认是 0.0.0.0)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md41"></a>
5. 概要设计</h1>
<p><b>TinyRPC</b> 框架的主要模块包括：异步日志、协程封装、Reactor封装、Tcp 封装、TinyPb协议封装、HTTP 协议封装、以及 RPC封装模块等。</p>
<h2><a class="anchor" id="autotoc_md42"></a>
5.1. 异步日志模块</h2>
<p>设计初期，**TinyRPC** 的日志主要参考了 (<b>sylar</b>),并精简后实现了最基础的打印日志。</p>
<p>在开发到一定程度后，发现同步日志或多或少有些影响性能，毕竟每次写入文件的磁盘IO还是比较耗时的。遂改为异步日志。TinyRPC 的异步日志实现非常简单，只是额外启动了一个线程来负责打印日志罢了。</p>
<p>当然，**TinyRPC** 的日志做到了了以下几点：</p><ul>
<li><b>异步日志**：日志异步打印，不阻塞当前线程。生产者只需要将日志信息放入buffer即可，消费者线程会按照一定时间频率自动将日志同步到磁盘文件中。</b></li>
<li><b>**日志级别**：日志分级别打印，**当设定级别高于待打印日志的级别时，日志打印是个空操作**，无性能消耗。</b></li>
<li><b>**文件输出**：日志支持可以输出到文件中，特别是在生产环境上，把日志打印到控制台可不是一个好方法。</b></li>
<li><b>**滚动日志**：日志文件会自行滚动，当**跨天**或者**单个文件超过一定大小**后，会自动建立新的文件写入日志信息。</b></li>
<li><b>**崩溃处理**：TinyRPC 的日志库处理了**程序突然崩溃**的情况，简单来说就是当程序崩溃退出前先将日志信息同步到磁盘文件上。这是非常重要的，如果缺失了崩溃那一瞬间的日志内容，那就很难排查具体原因。</b></li>
<li><b>**日志分类**：TinyRPC 提供了两类日志类型，**RPC 框架日志**以及 **APP 应用日志**。RPC 框架日志以 rpc 后缀结尾，是 TinyRPC 框架在运行中打印的日志信息，通常用来监控框架本身的运行状态。APP 应用日志以 **app</b> 后缀结尾 专门用来处理用户请求，对于每一个客户端请求，APP 日志会打印出请求的 msg 作为标识。总的来说，如果你只是使用 TinyRPC，关注APP日志即可。</li>
</ul>
<p>你可以分别使用宏定义 <b>DebugLog</b> 和 <b>AppDebugLog</b> 打印这两种日志: </p><div class="fragment"><div class="line">DebugLog &lt;&lt; &quot;11&quot;;</div>
<div class="line">AppDebugLog &lt;&lt; &quot;11&quot;;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md43"></a>
5.2. 协程模块</h2>
<h3><a class="anchor" id="autotoc_md44"></a>
5.2.1. 协程封装</h3>
<p>TinyRPC 的协程底层切换使用了腾讯的开源协程库 <a href="https://github.com/Tencent/libco">libco</a>，即协程上下文切换那一块，而协程切换的本质不过是寄存器切换罢了。 除了协程切换之外，TinyRPC 提供了一些基本函数的 hook，如 read、write、connect 等函数。</p>
<p>更多协程的介绍请移步我的知乎文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/466349082">C++实现的协程网络库tinyrpc（一）&ndash; 协程封装</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/474353906">C++实现的协程网络库tinyrpc（二）&ndash; 协程Hook</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/462968883">协程篇（一）&ndash; 函数调用栈</a></p>
<h3><a class="anchor" id="autotoc_md45"></a>
5.2.2. m:n 线程:协程模型</h3>
<p>最初设计中 TinyRPC 框架是 <b>1:n</b> 线程:协程模型的，即一个线程对于 n 个协程。每个线程有单独的协程池，线程只会 Resume 属于它自己协程池里面的协程，各个 IO 线程之前的协程互相不干扰。</p>
<p>然而 <b>1:n</b> 模型可能会增加请求的时延。例如当某个 IO 线程在处理请求时，耗费了太多的时间，导致此 IO 线程的其他请求得不到及时处理，只能阻塞等待。</p>
<p>因此 TinyRPC 框架使用 <b>m:n 线程:协程**模型进行了重构。所谓 **m:n</b> 即 m 个线程共同调度 n 个协程。由于 m 个线程共用一个协程池，因此协程池里的就绪任务总会尽快的被 **Resume**。</p>
<p>一般来说，每一个客户端连接对象 <b>TcpConnection</b>, 对应一个协程。对客户端连接的 <b>读数据、业务处理、写数据**这三步，其实都在这个协程中完成的。对于 **m:n 协程模型</b> 来说，一个 **TcpConnection**对象所持有的协程，可能会来回被多个不同的**IO线程**调度。</p>
<p>举个例子，协程 A 可能先由 IO线程1 Resume，然后协程 A Yield后，下一次又被 IO线程2 Resume 唤醒。</p>
<p>因此，在实现业务逻辑的时候，要特别谨慎使用**线程局部变量(thread_local)**。因为对当前协程来说，可能执行此协程的线程都已经变了，那对于的线程局部变量当然也会改变。</p>
<p>当然，**一个协程任一时刻只会被一个线程来调度，不会存在多个 IO 线程同时 Resume 同一个协程的情况**。这一点由 TinyRPC 框架保证。</p>
<p>不过，m:n 模型也引入了更强的**线程竞争条件**，所以对协程池加**互斥锁**是必须的。</p>
<h2><a class="anchor" id="autotoc_md46"></a>
5.3. Reactor 模块</h2>
<p>可移步知乎文章：</p>
<p><a href="https://zhuanlan.zhihu.com/p/503323714">C++实现的协程网络库tinyrpc（四）&ndash; Reactor 实现</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/428693405">Reactor模式介绍</a></p>
<h2><a class="anchor" id="autotoc_md47"></a>
5.4. Tcp 模块</h2>
<h3><a class="anchor" id="autotoc_md48"></a>
5.4.1. TcpServer</h3>
<p>TcpServer 的运行逻辑如下：</p>
<p><img src="imgs/tcp_server.drawio.png" alt="" class="inline"/></p>
<p>原理可参考文章： <a href="https://zhuanlan.zhihu.com/p/523947909">C++实现的协程异步 RPC 框架 TinyRPC（五）&ndash; TcpServer 实现</a></p>
<h3><a class="anchor" id="autotoc_md49"></a>
5.4.2. TcpConnection</h3>
<p>TcpConnection 运行逻辑如下：</p>
<p><img src="imgs/input.drawio.png" alt="" class="inline"/></p>
<p>原理可参考文章： <a href="https://zhuanlan.zhihu.com/p/524517895">C++实现的协程异步 RPC 框架 TinyRPC（六）&ndash; TcpConnection 实现</a></p>
<h2><a class="anchor" id="autotoc_md50"></a>
5.5. TinyPB 协议</h2>
<p>TinyPB 是 TinyRPC 框架自定义的一种轻量化协议类型，它是基于 google 的 protobuf 而定制的，读者可以按需自行对协议格式进行扩充。</p>
<h3><a class="anchor" id="autotoc_md51"></a>
5.5.1. TinyPB 协议报文格式分解</h3>
<p><b>TinyPb</b> 协议包报文用 c++ 伪代码描述如下： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">/*</div>
<div class="line">**  min of package is: 1 + 4 + 4 + 4 + 4 + 4 + 4 + 1 = 26 bytes</div>
<div class="line">**</div>
<div class="line">*/</div>
<div class="line">char start;                         // 代表报文的开始， 一般是 0x02</div>
<div class="line">int32_t pk_len {0};                 // 整个包长度，单位 byte</div>
<div class="line">int32_t msg_req_len {0};            // msg_req 字符串长度</div>
<div class="line">std::string msg_req;                // msg_req,标识一个 rpc 请求或响应。 一般来说 请求 和 响应使用同一个 msg_req.</div>
<div class="line">int32_t service_name_len {0};       // service_name 长度</div>
<div class="line">std::string service_full_name;      // 完整的 rpc 方法名， 如 QueryService.query_name</div>
<div class="line">int32_t err_code {0};               // 框架级错误代码. 0 代表调用正常，非 0 代表调用失败</div>
<div class="line">int32_t err_info_len {0};           // err_info 长度</div>
<div class="line">std::string err_info;               // 详细错误信息， err_code 非0时会设置该字段值</div>
<div class="line">std::string pb_data;                // 业务 protobuf 数据，由 google 的 protobuf 序列化后得到</div>
<div class="line">int32_t check_num {0};             // 包检验和，用于检验包数据是否有损坏</div>
<div class="line">char end;                           // 代表报文结束，一般是 0x03</div>
</div><!-- fragment --><p>注释信息已经很完整了。另外几个需要特殊说明的字段如下：</p>
<p><b>err_code</b>: err_code 是框架级别的错误码，即代表调用 RPC 过程中发生的错误，如对端关闭、调用超时等。err_code 为0 代表此次 RPC 调用正常，即正常发送数据且接收到回包。非 0 值代表调用失败，此时会设置 err_info 为详细的错误信息。</p>
<p><b>service_full_name</b> : 是指的调用的完整方法名。即 servicename.methodname。一般来说，一个 <b>TinyPB**协议的**TinyRPC</b> 服务需要注册至少一个 <b>Service</b> (这里的 Service 指的继承了google::protobuf::Service 的类)，而一个 Service 下包含多个方法。</p>
<p><b>pk_len</b>: pk_len 代表整个协议包的长度，单位是1字节，且包括 <b>[strat]</b> 字符 和 <b>[end]</b> 字符。</p>
<p><b>TinyPb</b> 协议报文中包含了多个 len 字段，这主要是为了用空间换时间，接收方在提前知道长度的情况下，更方便解码各个字段，从而提升了 decode 效率。</p>
<p>另外，**TinyPb** 协议里面所有的 int 类型的字段在编码时都会先转为**网络字节序**！</p>
<h2><a class="anchor" id="autotoc_md52"></a>
5.6. Http 模块</h2>
<p>TinyRPC 的 HTTP 模块实际上有点模仿 Java 的 Servlet 概念，每来一个 HTTP 请求就会找到对应的 HttpServlet 对象，执行其提前注册好的业务逻辑函数，用于处理 Http 请求，并回执 Http 响应。</p>
<h2><a class="anchor" id="autotoc_md53"></a>
5.7. RPC 调用封装</h2>
<p>&ndash;建设中，敬请期待&ndash;</p>
<h1><a class="anchor" id="autotoc_md54"></a>
6. 错误码</h1>
<h2><a class="anchor" id="autotoc_md55"></a>
6.1. 错误码判断规范</h2>
<p><b>TinyPB</b> 协议使用错误码来标识 RPC 调用过程的那些不可控的错误。这些错误码是框架级错误码，当出现这些错误码时，说明是 RPC 调用的链路出了问题。自然，这次 RPC 调用是失败的。 一般来说，在调用 RPC 时，需要判断两个错误码，例如： </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">stub.query_name(&amp;rpc_controller, &amp;rpc_req, &amp;rpc_res, NULL);</div>
<div class="line">// 判断框架级别错误码</div>
<div class="line">if (rpc_controller.ErrorCode() != 0) {</div>
<div class="line">  ErrorLog &lt;&lt; &quot;failed to call QueryServer rpc server&quot;;</div>
<div class="line">  // ....</div>
<div class="line">  return;</div>
<div class="line">}</div>
<div class="line">// 判断业务错误码</div>
<div class="line">if (rpc_res.ret_code() != 0) {</div>
<div class="line">  // ...</div>
<div class="line">  return;</div>
<div class="line">}</div>
</div><!-- fragment --><p>rpc_controller.ErrorCode 是 RPC **框架级错误码**，即这个文档里面锁描述的东西。该错误码的枚举值已经被定义好如下表格，一般情况下不会变更。当此错误码不为0时，请检查 RPC 通信链路是否有问题，网络连接是否有异常。当然，TinyPB 协议里面的 err_info 字段也会详细的描述错误信息。</p>
<p>另一个错误码是**业务错误码**，通常他被定义在 RPC 方法返回结构体的第一个字段中。出现这个错误码一般是对端在进行业务处理时出现了非预期的结果，此时将返回对应的错误码和错误信息。这个错误码的枚举值应由 RPC 通信双方自行约定。</p>
<h2><a class="anchor" id="autotoc_md56"></a>
6.2. 错误码释义文档</h2>
<p>err_code 详细说明如下表：</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"><b>错误码</b>   </th><th class="markdownTableHeadNone"><b>错误代码</b>   </th><th class="markdownTableHeadNone"><b>错误码描述</b>    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_PEER_CLOSED   </td><td class="markdownTableBodyNone">10000000   </td><td class="markdownTableBodyNone">connect 时对端关闭，一般是对端没有进程在监听此端口    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_FAILED_CONNECT   </td><td class="markdownTableBodyNone">10000001   </td><td class="markdownTableBodyNone">connect 失败    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_FAILED_GET_REPLY   </td><td class="markdownTableBodyNone">10000002   </td><td class="markdownTableBodyNone">RPC 调用未收到对端回包数据    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_FAILED_DESERIALIZE   </td><td class="markdownTableBodyNone">10000003   </td><td class="markdownTableBodyNone">反序列化失败，这种情况一般是 TinyPb 里面的 pb_data 有问题    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_FAILED_SERIALIZE   </td><td class="markdownTableBodyNone">10000004   </td><td class="markdownTableBodyNone">序列化失败    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_FAILED_ENCODE   </td><td class="markdownTableBodyNone">10000005   </td><td class="markdownTableBodyNone">编码失败    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_FAILED_DECODE   </td><td class="markdownTableBodyNone">10000006   </td><td class="markdownTableBodyNone">解码失败    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_RPC_CALL_TIMEOUT   </td><td class="markdownTableBodyNone">10000007   </td><td class="markdownTableBodyNone">调用 RPC 超时, 这种情况请检查下 RPC 的超时时间是否太短    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_SERVICE_NOT_FOUND   </td><td class="markdownTableBodyNone">10000008   </td><td class="markdownTableBodyNone">Service 不存在，即对方没有注册这个 Service    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_METHOD_NOT_FOUND   </td><td class="markdownTableBodyNone">10000009   </td><td class="markdownTableBodyNone"><a class="el" href="classMethod.html">Method</a> 不存在，对方没有这个 方法    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">ERROR_PARSE_SERVICE_NAME   </td><td class="markdownTableBodyNone">10000010   </td><td class="markdownTableBodyNone">解析 service_name 失败    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">ERROR_NOT_SET_ASYNC_PRE_CALL   </td><td class="markdownTableBodyNone">10000011   </td><td class="markdownTableBodyNone">非阻塞协程式 RPC 调用前没保存对象   </td></tr>
</table>
<h1><a class="anchor" id="autotoc_md57"></a>
7. 问题反馈</h1>
<ul>
<li>交流群：**260423934**</li>
<li>邮箱地址：**1753009868@qq.com**</li>
<li>知乎：知乎搜索 <b>ikerli</b></li>
</ul>
<p>如果您愿意支援一点电费，不胜感激！</p>
<p><img src="./imgs/mine/wechatpay.png" alt="" class="inline"/>(wechat pay) &#160; <img src="./imgs/mine/alipay.png" alt="" class="inline"/>(alipay) <br  />
</p>
<h1><a class="anchor" id="autotoc_md58"></a>
8. 参考资料</h1>
<p>libco: <a href="https://github.com/Tencent/libco">https://github.com/Tencent/libco</a></p>
<p>sylar: <a href="https://github.com/sylar-yin/sylar">https://github.com/sylar-yin/sylar</a></p>
<p>muduo: <a href="https://github.com/chenshuo/muduo">https://github.com/chenshuo/muduo</a></p>
<p>tinyxml: <a href="https://github.com/leethomason/tinyxml2">https://github.com/leethomason/tinyxml2</a></p>
<p>protobuf: <a href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
制作者&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
